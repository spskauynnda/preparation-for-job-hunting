# 腾讯（学校专场）二面凉经

## 一面

1. react的特性

   虚拟DOM/无状态组件(props)/有状态组件(state)/JSX/单向数据流

2. 谈一下闭包

   可以参考 https://segmentfault.com/a/1190000002778015

   **定义**：一个函数**有权**调用另一个函数作用域内的变量，被内部函数访问的外部函数的变量可以保存在外部函数作用域内而**不被回收**。最常见的就是一个函数内部创建另一个函数，调用外部函数的变量。

   （市面上的面试题把闭包诠释得很复杂，又是自执行的匿名函数，又是同步异步的，这些知识本质上是需要区分开来理解的）

   最简单的例子：

   ````
   var sayName = function(){
       var name = 'jozo';
       return function(){
           alert(name);
       }
   };
   var say = sayName(); 
   say();
   ````

   **缺点**：通常来说，js在混合编译的V8引擎下，不再被调用的变量会被垃圾回收(**GC**)机制清除。但是！如果创建了闭包，那被闭包调用的外部变量就会被长期保存在内存中，造成空间占用甚至内存泄漏

   **场景1**：一个最经典的面试题就是使用闭包解决for循环中循环变量的异步调用问题，例如

   ````
   for ( var i=0; i<5; i++) {
       setTimeout( function timer() {
       	console.log( i );
       }, 0 );
   }
   // 5 5 5 5 5
   ````

   这个例子涉及作用域以及 **事件循环机制（Event Loop）**中的同步和异步队列的调用顺序问题，由于setTimeout属于异步宏任务，js引擎会先把同步任务执行完毕再执行异步任务。而又由于for循环本身不构成块级作用域，用var定义的循环变量实际上不是定义在for循环内，而是定义在for所处的作用域（即外部环境）内，导致for循环执行完才会执行setTimeout函数，此时的i为5，所以输出5个5

   解决这个问题除了弥补for循环无法创建块级作用域的不足->使用let来声明变量以外，就得使用闭包了

   ````
   for (var i = 1; i <= 5; i++) {
       (function(j) {
           setTimeout(function timer() {
           	console.log(j);
           }, 1000);
       })(i);
   }
   ````

   这里的所谓闭包，就是使用一个自执行的匿名函数`(function(){...})(i)`，在每层循环中都创建一个内部的作用域，将变量i保存下来

   **场景2**：使用闭包可以包装函数，减少函数使用时所需要传入的参数（**函数柯里化**），或是隐藏一些私有变量

   ````
   // 普通的add函数
   function add(x, y) {
       return x + y
   }
   
   // Currying后
   function curryingAdd(x) {
       return function (y) {
           return x + y
       }
   }
   
   add(1, 2)           // 3
   curryingAdd(1)(2)   // 3
   ````

3. es6了解多少（let和const的区别/如何从两个数组中取出重复元素）

   `let res = arr1.filter((item) => {return arr2.includes(item)})`

4. 你最印象深刻的最有挑战性的学习/项目是哪次

5. 谈谈你页面渲染的优化方案（一般是cdn/服务端渲染和雪碧图之类的效果最明显）

   （最常用的四个：使用react/vue的路由方案来切换页面，避免白屏渲染，我们是一个一个html的，没办法只能通过url触发页面切换，没法做；cdn加速/服务端渲染，这两个不适用于招办的离线环境；雪碧图，这个只适用于对图片加载的优化）

   * 把js放在body最后加载，调整js文件的加载顺序，拆分js文件，减少特大js文件的加载速度

   * vue在渲染迭代对象时尽量使用key，可以提高vue的diff算法效率；用item自身的id而不是index，否则颠倒顺序之后，index完全不同，则会视为不同的组件重新渲染

   * 页面里很少变动的用v-if，变动的多的用v-show（if切换时性能差，show加载时性能差）

     v-if和v-for不要同用 / 使用computer

6. 说一下promise的特性（主要就是链式调用和async/await）

   * 传统的ajax容易陷入**回调地狱**

   * Promise**链式调用**，解决了回调地狱

     Promise中的async await可以用同步的方式写异步
   
   * fetch默认不带cookie

     fetch服务器返回400 500 状态码时并不会reject/ajax只接受200和304

7. http和https的区别

   * https是带了安全性SSL加密的http协议，双向的身份验证
   * 端口不一样，http是80端口，https是443端口
   * http的连接是无状态的（数据包的发送、传输和接受都是相互独立的），https则可以验证连接者的身份

8. 输入url到看到页面之间经过了什么（经典题）

9. 你项目中提到的复杂表单及交互逻辑有多复杂（简历给自己挖坑了，以示警戒）

10. 如果让你带领团队来架构并推动一个新项目，你会怎么做（我的理解里，最重要的是确认需求/根据需求进行技术选型/分模块实现功能并再次确认需求/测试，保证安全性和性能）

## 二面

1. 谈谈你的学习道路（这里答得很浅，只说了自己在学已有的东西，没有自己尝试去理解源码，理解底层）

2. 谈js的函数自执行（当时不知道自执行函数就是申明的同时立即调用）

      一般函数自执行就是函数外面包个() 然后后面再接个括号

      这种情况都不用给函数命名了，直接使用自执行的匿名函数（结合箭头函数）

      ( ( ) => {}) ( )

      ( ( ) => {} ( ) )

      自执行函数可以用于闭包、替代if使程序更简洁等场景，例如：

      `(判断表达式) && (function( ){ } ())` 前面的表达式如果为真，则立即执行后面的函数

3. 谈谈js的闭包，匿名函数

4. 谈谈 console.info('a')
       setTimeOut(function(){console.info('b')}, 0)
       console.info('c')
   的运行顺序，以及为什么

   （主要考察事件循环机制的理解，这个问题还是比较简单的，但是当时没回答清楚，其实很简单，事件循环机制中先执行可执行的同步任务，遇到异步任务就让他们进异步队列，同步任务执行完毕了再根据异步队列执行任务。）
   
   题目中哪怕第二行是0秒后执行，也会进异步队列，何况在js中定时器有个最小间隔（改动过，印象中现在是4ms），因此输出顺序是：a c b
   
   （异步任务还分为宏任务和微任务，执行异步队列的时候先执行异步微任务再执行宏任务。setTimeout和ajax的回调函数是常见的宏任务，Promise.then和async是常见的微任务）
   
5. 谈谈js是单线程的吗？谈谈js中的线程，进程，协程

   （面试官一听我前一个问题没回答好就乐了，赶紧问我js是单线程还是多线程的，以及js中的线程和进程是什么）

   进程是系统分配资源的单位，线程是系统调度的单位

   js只有一个js引擎线程。而浏览器有5个线程，但它们各自有各自单独的任务。

   其中**GUI渲染线程**是负责渲染、重绘、回流的，**JS引擎线程**又称为js内核，是负责处理js脚本程序的，例如V8引擎。而这两个内核是互斥的，也就是说两个进程交替执行，一个线程空闲时才会开始执行另一个线程，这并非是机能限制，而是因为这两个线程都有可能会更改页面元素，如果同时进行，渲染就可能会出现不可预期的结果。

   **事件触发线程**，该线程就是存放事件循环机制中的异步任务的，当需要触发时，把该线程中的事件添加到js引擎队尾，实际上并不在这个线程下执行事件任务

   **定时触发器线程**，计算定时任务的

   **异步HTTP请求线程**，主线程准备发起请求后，就把这个任务交给异步线程去处理，如果触发了回调函数，再把回调放进事件队列里让JS引擎去执行

6. 事件循环机制

7. 谈谈react的无状态组件

8. 如何理解react的单向数据流。从传入一个状态到渲染，每个节点都发生了什么？

9. 谈谈react的中间件