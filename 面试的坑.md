# 面试的坑

## 一、网络基础

### 1. tcp/udp

|          | TCP                                              | UDP                                |
| :------- | ------------------------------------------------ | ---------------------------------- |
| 可靠性   | 可靠                                             | 不可靠                             |
| 连接性   | **有连接**                                       | 无连接                             |
| 报文     | 面向字节流                                       | 面向报文                           |
| 效率     | 低                                               | 高                                 |
| 双工性   | 全双工                                           | **一对一、一对多、多对一、多对多** |
| 流量控制 | 滑动窗口                                         | 无                                 |
| 拥塞控制 | 慢开始、拥塞避免、快重传、快恢复                 | 无                                 |
| 传输速度 | 慢                                               | 快                                 |
| 应用场景 | 对效率要求低，对准确性要求高或者要求有连接的场景 | 对效率要求高，对准确性要求低       |

TCP的常见应用有：SMTP、TELNET、HTTP、FTP

UDP的常见应用有：DNS、TFTP、SNMP、NFS

### 2. tcp三次握手四次挥手

#### 为什么需要三次握手

加入client发出的第一个连接请求报文段滞留了很久才到达server，其实已经失效了，但server误认为这是一个client新的连接请求，假如只有两次握手，那服务端发出请求后就建立了连接，浪费了很多资源。

#### 为什么挥手要多一次

服务端向客户端返回应答后，可能不会立即关闭连接，还需要向客户端进行数据推送。直到没有数据需要推送了，才会关闭连接。

### 3. 状态码

**1XX：通知**

**2XX：成功**

200：一切正常

206：服务器已经处理了部分请求

​		   当页面上有较大的pdf、视频，或迅雷之类的工具需要断点续传、多线程下载时，该状态码可用于标志状态位

**3XX：重定向**

301：永久重定向

302：临时重定向

304：文档内容没有失效，浏览器使用本地缓存

**4XX：客户端错误**

401：需要用户验证

403：服务器已经理解请求，但是拒绝执行

404：无此资源

410：曾经有该资源，现在没有

**5XX：服务端错误**

### 4. http和https的区别

简化版解释：

对称加密：加密解密只有一个钥匙

非对称加密：服务端私钥，客户端公钥，私钥可以一对多

证书：如果服务端在给客户端发放公钥的时候被截取了，也就失去了安全性，所以要找第三方机构来申请和颁发证书

SSL过程：服务端申请证书，先将内容进行对称加密，然后再用非对称加密进行身份验证，最后通过MD5散列算法确认文件完整性。

> https://tyler-zx.blog.csdn.net/article/details/107591115

### 5. http是基于tcp的还是基于udp的

​	http2.0之前基本上都基于tcp，因为http需要建立可靠连接

​	http3.0谷歌选择在udp的基础上进行改造，兼容http2.0的同时进一步解决响应慢的问题

​	quic解决了以下几个问题

* **队头阻塞问题**（HTTP层队头阻塞和TCP层队头阻塞。http2.0多路复用解决了队头阻塞，但tcp层还存在阻塞）

  TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。

  QUIC协议是基于UDP协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。

* **0 RTT建链**

  一般来说HTTPS协议要建立完整链接包括:TCP握手和TLS握手，总计需要至少2-3个RTT，普通的HTTP协议也需要至少1个RTT才可以完成握手。

  然而，QUIC协议可以实现在第一个包就可以包含有效的应用数据，从而实现0RTT，但这也是有条件的。

  首次连接使用DH密钥交换算法。

* **前向安全**

  前向安全或前向保密Forward Secrecy是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。

* **前向纠错**

* **连接迁移**

### 6. 从url到页面加载经历的过程

​	https://blog.csdn.net/qq_42033567/article/details/107414221

  (1) DNS解析

  * 浏览器缓存解析/操作系统缓存解析/本地DNS服务器解析/其他DNS服务器解析(根、顶级、其他)

  * 将结果缓存，返回给浏览器

  * 向本地DNS服务器递归查询，向其他DNS服务器迭代查询

  (2) 发起TCP连接

  * 三次握手

  a. SYN = 1    seq = x

  b. ACK = 1    SYN = 1    ack = x+1    seq = y

  c. ACK = 1    ack = y+1

  (3) 客户端发起HTTP请求

  * 请求报文：请求行+请求头+空行+消息体

  (4) 服务端接受HTTP请求，返回HTTP响应

  * 响应报文：状态行+响应头+空行+消息体

  (5) 结束TCP连接

  * 四次挥手

​		a. FIN = 1    ack = z    seq = X

​		b. ACK = x+1    seq = z

​		c. FIN  = 1    ack = X    seq = Y

​		d. ACK = Y    Seq = X

 (6) 收到请求，解析渲染页面

  * 解析HTML，构建DOM树
  * 解析CSS，构建CSSOM树
  * 合并DOM和CSSOM树，生成render树
  * **布局**，计算布局
  * **绘制**，将布局渲染到屏幕上

### 7.http各个版本的区别

[《图解HTTP》](https://www.jianshu.com/p/d3268aa4ae84)

HTTP/1.0 短链接

HTTP/1.1 长连接，管道机制（发请求不用等待回应，服务端依次执行）

HTTP/2.0 二进制分帧，多路复用（不用等了），头部压缩，服务端可以推送

### 8. 滑动窗口

### 9. 拥塞控制

### 10. 强缓存和协商缓存

https://blog.csdn.net/woleigequshawanyier/article/details/86152516

(1). **强制性缓存**：客户端自给自足

当浏览器去请求某个文件时，服务端就在respone header里对该文件做缓存配置，例如respone header中的cache-control，常见的设置是max-age public private no-cache no-store等

当设置了max-age时间时：

**public**：客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 。如果用户做了刷新操作，就向服务器发起http请求（即协商缓存）

**private**：只让客户端可以缓存该资源；代理服务器不缓存
 客户端在xxx秒内直接读取缓存,statu code:200

**immutable**：客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

**no-cache**： 跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。

**no-store**： 不缓存，这个会让客户端、服务器都不缓存，没有强缓存、协商缓存，直接向服务器请求新的资源。

expires也可以设置缓存的最终失效时间，与cache-control同时使用时后者优先级更高

<img src="D:\Work\preparation-for-job-hunting\img\HTTP缓存决策图.png" style="zoom:67%;" />

````
决策流程：
if 可复用（需要缓存）
	[no-store] 不使用任何缓存
else 
if 需要向服务器确认缓存是否有效
	[no-cache] 不保存本地缓存
else
if 需要服务器缓存
	[public]
else 
	[private]
````



(2). **协商缓存**：由服务器确定本地的缓存资源是否可用

在response header里设置如下属性，并在下次请求时在request header中带上它们：

````bash
etag: '5c20abbd-e2e8'
last-modified: Mon, 24 Dec 2018 09:49:49 GMT
````

etag为文件的hash，每个文件唯一，last-modified为精确到秒的文件最终修改时间。服务端根据这两个标识进行比对，判断是否需要返回新的资源：如果没有变，那就不变etag和last-modified

流程：

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回**304**状态码-->客户端用缓存的老资源。

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->过期-->返回**200**状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。

总结：

请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
如果资源没更改，返回304，浏览器读取本地缓存。
如果资源有更改，返回200，返回最新的资源。

补充：

```csharp
// response header中的etag、last-modified在客户端重新向服务端发起请求时，会在request header中换个key名：
// response header
etag: '5c20abbd-e2e8'
last-modified: Mon, 24 Dec 2018 09:49:49 GMT
// request header 变为
if-none-matched: '5c20abbd-e2e8'
if-modified-since: Mon, 24 Dec 2018 09:49:49 GMT
```

牛角尖：为什么要有etag？

* 有的文件会周期性更改，但内容不改变
* 有的文件更新频率过快，而if-modified-since的检查粒度只到秒级
* 某些服务器不能精确得到文件的最后修改时间

### 11. 127.0.0.1和0.0.0.0

127.0.0.1是一个IPv4地址，共有32位，一个字节8位，共4个字节

其中127开头的都属于回环地址

0.0.0.0是一个空地址，在nginx中监听该地址代表监听本地所有的地址

### 12. ping数据和TCP发数据的关系

https://blog.csdn.net/qq_34162294/article/details/119431331

![img](https://img-blog.csdnimg.cn/img_convert/c46c6ea4240d756b048e290c21816d78.png)

## 二、ES5

### 1. apply/call/bind

* 共同点：都是用来重定义this对象的

  objA.foo.call(ObjB, ...) 

  objA.foo.apply(ObjB, ...)

  **objA.foo.bind(ObjB, ...)()**

* 区别1：call和apply返回的是foo方法的返回值，bind返回的是一个新函数

* 区别2：

  (1) 使用call时，后续参数**以逗号分割**传入被调用的函数中

  (2) 使用apply时，后续输入参数必须放在一个**数组**中传入

  (3) bind**返回是函数**，传入参数和call一样

* 用途——react中的bind

  **类的方法默认不会绑定this，如果忘记绑定，则传入函数名并调用时，this值会是undefined**

  解决方法：bind或箭头函数

  1. 在构造函数constructor 内绑定`this.handleClick = this.handleClick.bind(this)`
  2. `handleClick = () => { ... }`
  3. 
	
  ```javascript
  handleClick ( ) { ... }
  
  render() {
  	return (
   		<button onClick={(e) => this.handleClick(e)}> ...
   		</button>
  	 )
  }
  ```
  
* **手写bind** https://blog.csdn.net/q3254421/article/details/82999718

### 2. 原型链                                                                                                                                                                                              

![image-20210318200848599](.\img\原型链文字总结.png)

### 3. 闭包

可以参考 https://segmentfault.com/a/1190000002778015

细节：https://zhuanlan.zhihu.com/p/106287246

定义：一个函数**有权**调用另一个函数作用域内的变量，被内部函数访问的外部函数的变量可以保存在外部函数作用域内而**不被回收**。

（市面上的面试题把闭包诠释得很复杂，又是自执行的匿名函数，又是同步异步的，这些知识本质上是需要区分开来理解的）

最简单的例子：

   ````javascript
   var sayName = function(){
       var name = 'jozo';
       return function(){
           alert(name);
       }
   };
   var say = sayName(); 
   say();
   ````

#### 作用

**1**：隐藏变量，避免全局污染

**2**：可以读取函数内部的变量

#### 缺点

**1**：通常来说，js在混合编译的V8引擎下，不再被调用的变量会被垃圾回收(**GC**)机制清除。但是！如果创建了闭包，那被闭包调用的外部变量就会被长期保存在内存中，造成空间占用甚至内存泄漏

**2**：不恰当使用闭包，可能会造成内存泄漏

#### 原理

利用了作用域链的特性，如果当前的执行环境下不存在该变量就逐层向外寻找，直到全局作用域。

#### 场景

**场景1**：一个最经典的面试题就是使用**立即执行函数**解决**闭包**造成的for循环中循环变量的**异步调用**问题，例如

   ````javascript
   for ( var i=0; i<5; i++) {
       setTimeout( function timer() {
       	console.log( i );
       }, 0 );
   }
   // 5 5 5 5 5
   ````

   这个例子涉及作用域以及 **事件循环机制（Event Loop）**中的同步和异步队列的调用顺序问题，由于setTimeout属于异步宏任务，js引擎会先把同步任务执行完毕再执行异步任务。而又由于for循环本身不构成块级作用域，用var定义的循环变量实际上不是定义在for循环内，而是定义在for所处的作用域（即外部环境）内，导致for循环执行完才会执行setTimeout函数，此时的i为5，所以输出5个5

解决这个问题除了弥补for循环无法创建块级作用域的不足->使用let来声明变量以外，就得使用闭包了

   ````javascript
   for (var i = 1; i <= 5; i++) {
       (function(j) {
           setTimeout(function timer() {
           	console.log(j);
           }, 1000);
       })(i);
   }
   ````

   这里的所谓闭包，就是使用一个自执行的匿名函数`(function(){...})(i)`，在每层循环中都创建一个内部的作用域，将变量i保存下来

**场景2**：使用闭包可以包装函数，减少函数使用时所需要传入的参数（**函数柯里化**），或是隐藏一些私有变量

   ````javascript
   // 普通的add函数
   function add(x, y) {
       return x + y
   }
   
   // Currying后
   function curryingAdd(x) {
       return function (y) {
           return x + y
       }
   }
   
   add(1, 2)           // 3
   curryingAdd(1)(2)   // 3
   ````

**场景3**：实现变量在每次调用函数时自增

1. 使用全局变量，会污染全局的变量环境
2. 定义一个函数内部的变量，无法实现自增
3. 通过将变量定义在外部函数中，也就是通过闭包，就可以实现自增

**场景4**： 闭包创建独立变量环境，封装类库的内部变量

例如：使用闭包可以创建一个仅供debounce函数访问的计时器，实现防抖

### 3‘. 立即执行函数

#### (1) 触发立即执行函数不一定要用()，用! - +都可以

#### (2) 多个立即执行函数一起写，每个函数结尾要加个;

### 4. 匿名函数

【重点】非严格模式下，this指向window，严格模式下，this指向undefined。同时匿名函数是一个没有指针的全局变量，通过window并不能找到这个匿名函数，这种调用具有安全性和隐匿性。

并非匿名函数本身特殊，而是Property accessor语法影响了this。

先看**一般情况**，在运行 `obj.foo()` 时，根据属性访问语法，函数会调用运算符"()"的左边部分，获取一个base为obj的referenceType，然后进行函数调用运算，则referenceType.base会为该函数执行环境的this提供引用。

如果要消除referenceType带来的影响，很简单，`(1,obj,foo)()`就行了，因为分组运算符的加入，导致提前对referenceType进行了getValue操作，直接拿到函数对象进行函数调用运算，导致提供给该函数的执行环境关联的this值为null，在ES3中，规定此时glabal为this，而ES5的严格模式则修正了这一规则

外层分组运算符的作用是让 匿名函数表达式合法. 因 javascript 语法限制. 禁止函数表达式中, function 关键字出现在表达式的第一个token位置. so. 必须借助其他辅助语法来完成所谓匿名函数的立即调用..比如 赋值表达式,逗号运算等等。显然匿名函数解释执行的结果不是一个referenceType .但是规则中有表述,当不是referenceType时. 仍然把null (undefined-SE5) 作为this 提供给该函数执行环境.

完整问答链接：**匿名函数的this指向为什么是window?** https://www.zhihu.com/question/21958425/answer/19858492

### 5. Array.prototype.slice()

   Array.prototype.slice.call(arrLike)   等效于  [].slice.call(arrLike)   

   可用于将类数组对象arrLike转换为一个新数组

   ````javascript
   // 类数组对象-字符串的表现
   const str = '1234'
   str.slice() // '1234'
   [].slice.call(str)  // ['1','2','3','4']
   function list1(item){ return [].slice.call(item) }
   function list2(){ return [].slice.call(arguments) }
   list1(str)     // ['1','2','3','4']
   list2(str)     // '1234'
   ````

   ```javascript
   // mdn例子
   function list() {
     return Array.prototype.slice.call(arguments)
   }
   var list1 = list(1, 2, 3)  // [1, 2, 3]
   
   //使用bind"简化"list
   var unboundSlice = Array.prototype.slice
   var slice = Function.prototype.call.bind(unboundSlice)
   }
   function list() {
   	return slice(arguments)
   }
   var list2 = list(1,2,3)   // [1, 2, 3]
   ```

   ES6中Array.from()是该方法的新实现

### 6. 深拷贝浅拷贝

* Array.assign

  对象只有一层时为深拷贝，对象不止一层时为浅拷贝

* Array.create

* JSON.stringify

  ````javascript
  let newObj = JSON.parse(JSON.stringify(obj))
  ````

  很简单对吧，缺点是不能复制undefined、RegExp和原型

* 手写深拷贝函数

    ````javascript
    // 定义一个深拷贝函数  接收目标target参数
    function deepClone(target) {
        // 定义一个变量
        let result;
        // 如果当前需要深拷贝的是一个对象的话
        if (typeof target === 'object') {
        // 如果是一个数组的话
            if (Array.isArray(target)) {
                result = []; // 将result赋值为一个数组，并且执行遍历
                for (let i in target) {
                    // 递归克隆数组中的每一项
                    result.push(deepClone(target[i]))
                }
             // 判断如果当前的值是null的话；直接赋值为null
            } else if(target===null) {
                result = null;
             // 判断如果当前的值是一个RegExp对象的话，直接赋值    
            } else if(target.constructor===RegExp){
                result = target;
            }else {
             // 否则是普通对象，直接for in循环，递归赋值对象的所有值
                result = {};
                for (let i in target) {
                    result[i] = deepClone(target[i]);
                }
            }
         // 如果不是对象的话，就是基本数据类型，那么直接赋值
        } else {
            result = target;
        }
         // 返回最终结果
        return result;
    }
    ````

### 7. this指向

七条规则：参考掘金

(1) 箭头函数：箭头函数的this绑定在函数内部，不可修改

(2) new：使用new关键字构造的对象，其this指向生成的对象内部；不能使用箭头函数作为构造函数

(3) bind：Function.prototype.bind **多次bind时只取第一次**，与前两条规则同时出现时，服从于前两条规则

(4) call/apply：冲突时，服从于前三条

(5) obj.：

(6) **被直接调用**：除以上情况之外，被直接调用的时候，this将指向全局对象

````javascript
function outerFunc(){
	console.log(this) // {x:1}
	function func() {
		console.log(this) // window
	}
	func()
}
outerFunc.bind({x:1})
````

​	setTimeout和匿名函数也属于此类情况

(7) 不在函数里：如果在<script/>标签里，指向Window，如果在Nodejs模块文件里，指向Module的默认导出对象

### 8. 作用域链

定义：作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。

换句话说：作用域链什么时候发生作用？当前的作用域下如果没有定义这个变量（那它就成为了自由变量），如何去寻找这个自由变量的定义，就是作用域链的作用。

实现原理：基于[[scope]]

计算机制：见”进阶“

#### (1) 入门

```
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10

```

这个例子很有意思，由于var定义的变量没有块级作用域，所以实际上i定义在了全局环境中，而a[i] = function(){}这句并没有经过赋值，所以i的实际值并没有当场传入这个函数中，而是作为一个变量存入了函数中，而调用函数时，通过作用域链访问到了全局的这个i，所以i为10

#### (2) 进阶：作用域是“创建”的时候定义的，而不是“调用”的时候

```
var x = 10
function fn() {
  console.log(x)
}
function show(f) {
  var x = 20
  (function() {
    f() //10，而不是20
  })()
}
show(fn)
```

在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取，**无论fn函数将在哪里调用**。

因此在观察函数自由变量的取值时，要从定义函数的地方往上看，而不是调用的地方。



如何理解作用域链 https://www.zhihu.com/question/38963988/answer/663634596

深入理解JavaScript作用域和作用域链 https://segmentfault.com/a/1190000018513150

### 8’. 执行上下文

https://www.cnblogs.com/echolun/p/11438363.html

https://www.zhihu.com/question/36393048

### 9. 事件冒泡/捕获/事件委托

#### 关系

1. 事件冒泡是从触发事件的节点向ducument自下而上触发事件

2. 事件捕获是从document到触发事件的节点自上而下触发事件

   addEventListener的第三个参数控制冒泡/捕获，默认为冒泡（false），捕获为true

   特别地：父子元素没有重叠时，父子元素之间也会有冒泡/捕获

#### 执行顺序（先捕获，后冒泡；目标阶段，看注册顺序）

1. 一个DOM事件被触发时，经历三个阶段：捕获阶段、**目标阶段**、冒泡阶段。即先检查从document到事发节点之上的捕获事件，再检查从事发节点之上到ducument的冒泡事件。
2. 特殊的是，在目标阶段，如果事发元素同时注册了捕获和冒泡事件，是按**注册顺序**来执行，而不是先捕获再冒泡

#### 阻止冒泡

e.stopPropagation()

#### 事件委托

```javascript
$(document).ready(function () {
	$("#newslist").on("click", function (e) {
		$(e.target).css({ "background": "#f00" }).siblings().css({ "background": "#fff" });
    })
})
```

`e.target`表示在事件冒泡中触发事件的源元素

`e.target`可以用`this`代替

### 9‘. 事件机制

#### (1). kepup、keypress、keydown

```javascript
document.addEventListener('keydown', function(e){
    console.log(e.target.value)
})
document.addEventListener('keyup', function(e){
    console.log(e.target.value)
})
```



### 10. 防抖(debounce)和节流(throttle)

防抖：delay间隔内的连续操作，只有最后一次生效。用计时器实现。

节流：高频操作每delay间隔内才会触发一次。用时间戳或计时器实现。

### 11. 类型判断

#### (1). 数组类型

Object.prototype.toString.call()：全能

instanceof()：检测某构造函数上的原型是否存在于要检测对象的原型链上，只能返回true/false

Array.isArray()：比instanceof更好，能判断iframe数组

#### (2). 数值类型

特殊情况：Nan和-0

=== 无法判断NaN 

isNaN()可以判断是否为NaN

Object.is()可以判断NaN和-0

````javascript
NaN === NaN  // false
0 === -0     // true
isNaN(NaN)   // true
Object.is(-0, 0) // false
````

#### (3). 手写一个通用的类型判断函数

````javascript
const type = (a) => {
	return Object.prototype.toString.call(a).slice(8, -1)
}
````



### 12. for...in/for...of/forEach()的区别

#### (1). 遍历数组通常用for循环

forEach内不能单独用await，for可以

forEach不能用return或break中断循环，for可以

#### (2). for in 的特性

* index索引为字符串型，不能直接运算
* 遍历的是**数组的索引（键名）**，因此遍历顺序有可能不是按数组的内部顺序
* **使用for in会遍历所有的可枚举属性**，包括原型，因此for in更适合遍历对象

#### (3). for of 的特性

* for of 遍历的是数组内的元素，不包括数组的原型method和索引name。更适合使用在遍历数组中
* for of 遍历的是**数组元素值**
* for of 只能遍历 **iterable** 迭代器对象，对普通对象遍历会报错

#### (4). for in遍历对象

使用for in遍历对象时，如果不想遍历原型方法和属性，可以使用hasOwnProperty判断是否为该对象的实例属性

此时等同于Object.keys(myObject)

#### 总结

* for...in更适合用来遍历对象的可枚举属性

* for...of更适合用来遍历数组的元素

### 13. 前端跨域

同源策略：同协议、同域名、同端口

https://zhuanlan.zhihu.com/p/56718905

#### 跨域方案1 JSONP

````javascript
// index.html
function jsonp({ url, params, callback }) {
 return new Promise((resolve, reject) ={
 let script = document.createElement('script')
 window[callback] = function(data) {
      resolve(data)
 document.body.removeChild(script)
    }
    params = { ...params, callback } // wd=b&callback=show
 let arrs = []
 for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    script.src = `${url}?${arrs.join('&')}`
 document.body.appendChild(script)
  })
}
jsonp({
 url: 'http://localhost:3000/say',
 params: { wd: 'Iloveyou' },
 callback: 'show'
}).then(data ={
 console.log(data)
})
````

````javascript
// server.js
let express = require('express') 
let app = express() 
app.get('/say',
function(req, res) {
    let {
        wd,
        callback
    } = req.query console.log(wd) // Iloveyou
    console.log(callback) // show
    res.end(`$ {
        callback
    } ('我不爱你')`)
}) 
app.listen(3000)
````

#### 跨域方案2 CORS

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。发送请求时会出现两种情况：简单请求和复杂请求。简单请求只请求一次，复杂请求会在正式通信前发出一次“预检”请求，通过该请求来知道服务端是否支持跨域请求。

#### 跨域方案3 postMessage

postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的 iframe 消息传递
- 上面三个场景的跨域数据传递

**postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递**。

````
otherWindow.postMessage(message, targetOrigin, [transfer]);
````

#### 跨域方案4 websocket

#### 跨域方案5 nginx或nodejs反向代理

#### 跨域方案6 window.name + iframe

#### 跨域方案7 location.hash + iframe

#### 跨域方案8 document.domain + iframe

#### 总结

- CORS 支持所有类型的 HTTP 请求，是跨域 HTTP 请求的根本解决方案
- JSONP 只支持 GET 请求，JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。
- 不管是 Node 中间件代理还是 nginx 反向代理，主要是通过同源策略对服务器不加限制。
- 日常工作中，用得比较多的跨域方案是 cors 和 nginx 反向代理

### 14. 隐式类型转换  == 和 +

> https://www.cnblogs.com/superlizhao/p/8945432.html
>
> http://c.biancheng.net/view/5477.html

#### + 和 -

* +倾向于将数值和对象转换为字符串（调用toString()方法）

* -倾向于将字符串和对象转换为数值（调用Number()函数）

#### == 在转换不同数据类型时的规则

* Boolean：false=0  true=1
* String vs Number：Number(str)
* Object vs 非Object：obj.valueOf()
* Object vs Object：比较是否指向同一个对象
* null 和 undefined 是相等的——比较相等性之前，null 和 undefined 不能转换成其他任何值
* NaN：只要有至少一个NaN，相等运算符返回false

### 15. 创建对象

#### (1). 工厂模式

不足：能够创建对象，但是**无法区分对象的类型**

#### (2). 构造函数模式

优势：使用构造函数来创建函数的实例，函数的constructor属性指向构造函数，就可以区分对象类型了；可以自动绑定this；隐式创建对象

不足：每个方法都要在每个实例上重新创建一遍，浪费资源（当然也可以不在构造函数内部定义方法，只定义一个变量，变量指向一个作用域链中定义好的公共方法，但这样就反而失去了函数的封装性）

````
function Person() {

}
````



#### (3). 原型模式

优势：在javascript中，所有对象在创建的时候都会为其创建一个prototype属性，指向函数的原型对象

**常用方法**

* isPrototypeOf()   /   getPrototypeOf()
* hasOwnProperty()
* in操作符

不足：其属性和方法都是**共享**的，无法保存实例私有的属性

#### (4). 组合模式

同时使用构造+原型

#### (5). 动态原型模式

#### (6). 寄生构造函数模式

看一个例子

````javascript
function Person(name, age, job) {
	var o = new Object()
	o.name = name
	o.age = age
	o.job = job
	o.sayName = function() {
		console.log(this.name)
	}
	return o
}
var friend = new Person("Tom", 29, "Engineer")
friend.sayName()
````

这个例子中，混合了构造函数模式和工厂模式，这是构造函数存在return语句时的特殊情况，此时可以重写调用构造函数时返回的值。

优势：可以用于重写无法修改的Array等构造函数

缺陷：返回的对象与构造函数及其原型属性之间没有关系，因此不能使用instanceof操作符来确定对象类型。

### 16. 继承

#### (1).原型链

````javascript
subType.prototype = new SuperType()
````

#### (2). 借用构造函数

#### (3). 组合继承

例子

````javascript
function P(name) {
	this.name = name
	this.colors = ['red', 'green', 'blue']
}
P.prototype.sayName = function(){ console.log(this.name) }
function C(name, age) {
	P.call(this, name)   // name为构造P时需要传参的属性
	this.age = age       // age为C自己设置的新属性
}
C.prototype = new P()    // 先把原型继承过来
C.prototype.constructor = C  // 再把原型函数对应的constructor改成自己
C.prototype.sayAge = function(){ console.log(this.age) }
var objC = new C()
objC instanceof C  // true
````

#### (4). 原型式继承

````
function object(o) {
	function F() {}
	F.prototype = o
	return new F()
}
````

Object.create()实现了这一思想

#### (5). 寄生式继承

#### (6). 寄生组合式继承



## 三、ES6

> 主要内容
> 1. 函数的默认参数
> 2. 反引号：模板表达式/多行字符串
> 3. 拆包表达式：var { house, mouse} = $('body').data() 
> 4. 数组解构运算：...
> 5. Promise对象
> 6. 块作用域、let、const
> 7. 类
> 8. 模块化（标准实现CommonJS）
> 9. 数据结构（Map、Set）
> 10. 新函数和数组方法，如includes

### 1. var，const，let的区别

   var声明变量可以重复声明，而**let不可以重复声明**

   var是不受限于块级的，而let是受限于块级

　　var会与window相映射（会挂一个属性），而let不与window相映射

　　var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错

　　const声明之后必须赋值，否则会报错

　　const定义不可变的量，改变了就会报错

　　const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错

#### 没有变量提升、暂时性死区

var有变量提升，let和const没有

暂时性死区：

````javascript
var tmp = 123
if (true) {
  tmp = 'abc' // ReferenceError
  let tmp
}
````

存在let声明的这个代码块中，该变量不再受外部影响，且声明前调用该变量会报错（没有变量提升）

#### js的特殊用法

````javascript
let i
for (i=0; i<6; i++) {
	setTimeout(()=>{
		console.log(i)
	})
}  // 6 6 6 6 6 6

for (let i=0; i<6; i++) {
    // let i = i
	setTimeout(()=>{
		console.log(i)
	})
}  // 0 1 2 3 4 5
````

实际上js的引擎会在for和let同时出现时，默认在循环块头部加一句 `let i = i`

#### 词法环境、变量环境

词法环境存放函数声明与const let声明的变量，而变量环境只存储var声明的变量。

### 2. 查找两个数组的重复项

````javascript
let arrX = arr1.filter((item)=>arr2.includes(item))
````

   **Array.filter(function(){return 表达式})** 返回满足Array中满足表达式的元素

   **Array.includes()** indexOf的姊妹，它只返回true/false

### 3. 数组去重

````javascript
const uniq = function(){
   return Array.from(new Set(arguments[0]))
}
````

 但是该方法对两个相同的对象可能无效，因为在比较的时候比较的是两个对象的名，即两个指针，哪怕两个深拷贝一样的对象，其地址也可能不同

### 4. Promise

   手写Promise https://zhuanlan.zhihu.com/p/144058361

   Promise规范 https://es6.ruanyifeng.com/#docs/promise

#### (1). 含义

Promise是ES6提出的**异步编程**解决方案，Promise简单来说是一个**容器**，保存着某个未来才会结束的事件，从语法上说，Promise是一个对象，从它**可以获取异步操作的消息**

对比：ajax/fetch/axios/async/await

Promise对象的两大特点：

1. **对象状态不受外界影响**

   只有异步操作的结果，才能决定当前是哪一种状态。三种状态：`pending` `fulfilled` `rejected`

2. **一旦状态改变，就不会再变，且任何时候都能得到这个结果**

   两种状态改变的可能：从 `pending` 变为 `fulfilled`，或从 `pending` 变为 `rejected`。状态一经改变，就凝固了，不会再变，一直保持这个结果，称为 `resolved（已定型）` 。之后再对这个Promise对象添加回调函数，也会立即得到这个结果。

缺点：第一，一旦创建，就无法中途取消。第二，如果不设置回调函数，Promise内部抛出的错误是不会反应到外部的。第三，处于pending状态时，无法得知目前进展到哪一个阶段。

#### (2). Promise对象是一个构造函数，用来生成Promise实例

**基本用法**

````javascript
// 定义Promise对象
const promise = new Promise(function(resolve, reject){
	if (/*异步操作成功*/) {
		resolve(data)
	} else {
		reject(error)
	}
})

// promise.then接受两个参数，分别是成功和失败时的回调函数
promise.then(function(value) {
  /* success */
}, function(error) {
  /* failure */
});
````

**执行顺序/EventLoop**

Promise 新建后就会立即执行。promise.then会依次进入异步微任务队列。

**Promise嵌套**

````javascript
const p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error('fail')), 3000)
})
const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})
p2
  .then(result => console.log('resolve,', result))
  .catch(error => console.log('reject,', error))
// reject, fail
````

p2的计时器先到位，但要等到p1的Promise对象resolved后才能获取到p1

#### (3). Promise.prototype.then()

#### (4). Promise.prototype.catch()

`Promise.prototype.catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数。

**错误冒泡**

Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被下一个catch捕获为止

**推荐写法**

````javascript
// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });

// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });
````

第二种写法同时还可以捕获then方法执行中的错误，也更接近同步的写法

**警告**

如果没有catch捕获到错误处理，Promise对象抛出的错误是不会传递到外层代码的（Node中例外）

#### (5). Promise.prototype.finally()

`finally()`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。

finally也等同于then的特例，其实现方式：

```javascript
Promise.prototype.finally = function (callback) {
  let P = this.constructor;
  return this.then(
    value  => P.resolve(callback()).then(() => value),
    reason => P.resolve(callback()).then(() => { throw reason })
  );
};
```

finally方法总会返回原来的值

```javascript
Promise.reject(3).finally(() => {})
// 3
```

#### (6). Promise.all()

`Promise.all()`用于将多个Promise实例包装成一个新的Promise实例。接收一个数组作为参数，如果不是，就会调用resolve方法将参数转为Promise实例，再进一步处理。`Promise.all()`方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。

````javascript
const p = Promise.all([p1,p2,p3])
````

p的状态由p1p2p3共同决定。**仅当p1p2p3的状态都为fulfilled时，p才为fulfilled**，此时返回值为p1p2p3的返回值组成的数组。而如果**其中有一个被rejected，p就会变为rejected**，返回值为第一个被rejected的返回值。

````javascript
const databasePromise = connectDatabase();

const booksPromise = databasePromise 
  .then(findAllBooks);

const userPromise = databasePromise
  .then(getCurrentUser);

Promise.all([
  booksPromise,
  userPromise
])
.then(([books, user]) => pickTopRecommendations(books, user));
````

上面代码中，`booksPromise`和`userPromise`是两个异步操作，只有等到它们的结果都返回了，才会触发`pickTopRecommendations`这个回调函数。

**错误冒泡捕获**

只有子Promise没有自己的`catch`方法，才会调用`Promise.all()`的`catch`方法。

#### (7). Promise.race()

```javascript
const p = Promise.race([p1, p2, p3]);
```

**赛跑**

只要有一个实例率先改变状态，p的状态就跟着改变

````javascript
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000)
  })
]);

p
.then(console.log)
.catch(console.error);
````

如上，该方法可用于为请求设置最大请求时间，如果指定时间内没有获得结果，就将Promise的状态变为rejected

#### (8). Promise.allSettled()

接受一组Promise实例作为参数，只有等到所有参数实例都返回结果，包装实例才会结束。一旦结束，状态就总是fulfilled，不会变成rejected，状态fulfilled以后，Promise的监听函数接收到的是一个传入的Promise实例所组成的一个数组。

```javascript
const resolved = Promise.resolve(42);
const rejected = Promise.reject(-1);

const allSettledPromise = Promise.allSettled([resolved, rejected]);

allSettledPromise.then(function (results) {
  console.log(results);
});
// [
//    { status: 'fulfilled', value: 42 },
//    { status: 'rejected', reason: -1 }
// ]
```

使用的例子

```javascript
const promises = [ fetch('index.html'), fetch('https://does-not-exist/') ];
const results = await Promise.allSettled(promises);

// 过滤出成功的请求
const successfulPromises = results.filter(p => p.status === 'fulfilled');

// 过滤出失败的请求，并输出原因
const errors = results
  .filter(p => p.status === 'rejected')
  .map(p => p.reason);
```

相比较promise.all()而言，promise.allSettled() 能确定所有操作是否都结束

#### (9). Promise.any()

只要参数实例有一个变成`fulfilled`状态，包装实例就会变成`fulfilled`状态；如果所有参数实例都变成`rejected`状态，包装实例就会变成`rejected`状态。

该方法与all方法相反，而与race方法的差别在于不会因为某个Promise变成rejected状态而结束

(10). Promise.resolve()

该方法可以将现有对象转为Promise对象

四种情况：

* 参数是一个Promise实例：原封不动返回该实例
* 参数是具有then方法的对象：将该对象转为Promise对象，并**“立即”**执行thenable对象的then()方法
* 参数不是具有then方法的对象，或者根本不是对象

* 不带任何参数，则直接返回一个resolved状态的Promise对象

**需要注意的是，立即`resolve()`的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。**

#### (11). Promise.reject()

#### (12). Promise.try()

用途1：不影响事件循环的前提下，使同步事件后可以使用then方法（基本等同于resolve）

````javascript
const f = () => console.log('1')
Promise.resolve(f()).then()
// 等同于
Promise.try(f).then()
````

用途2：如果需要同时考虑处理来自同步的和来自异步的错误（比如抛出数据库连接异常错误）

````
Promise.try(() => database.users.get({id: userId}))
  .then(...)
  .catch(...)
````

#### Generator与Promise的结合

### 5. Generator

### 6. async/await

async/await是generator/yield的语法糖，async的实现原理就是将Generator函数和自动执行器包装在一个函数里。async函数返回一个Promise对象，可以使用then方法添加回调函数，当函数执行的时候，一旦遇到await就会先返回，等异步操作完成后再接着执行函数体后面的语句。

#### 错误处理

如果await后面的异步操作出错，等同于async返回的Promise对象被reject。为防止出错，可以为await添加catch，或者将其放在try...catch代码块中

#### 使用注意点

1. 错误处理

2. 如果多个await命令后面的异步操作不存在继发关系，可以使用all让他们同时触发

   ````javascript
   // 写法一：使用Promise.all
   let [foo, bar] = await Promise.all([getFoo(), getBar()])
   // 写法二：
   let fooPromise = getFoo()
   let barPromise = getBar()
   let foo = await fooPromise
   let bar = await barPromise
   ````

3. await命令只能用在async函数中，如果用在普通函数中就会报错

   如果想实现遍历，不要使用forEach，老老实实使用for循环或reduce()方法

#### 实现原理

#### 和其他异步方法的对比



## 四、框架

### 1. react Diff

   包含调和阶段（比较前后VirtualDOM的不同，动态更新不同的部分，其中主要涉及diff算法）和render阶段

   **react diff算法**——

   假如使用循环递归对节点进行依次对比，算法复杂度将达到 O(n^3) ，而使用diff算法可降低至O(n) 

   策略一（**tree diff**）：**只进行同级比较**
    Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。

   策略二（**component diff**）：**不同类的React组件会被当做完全不同的DOM结构而被完全替换**
    拥有相同类的两个组件 生成相似的树形结构，
    拥有不同类的两个组件 生成不同的树形结构。 

   策略三（**element diff**）：**对于同一层级的一组子节点，通过唯一id区分**
    开发人员可以通过给Virtual DOM一个唯一的key属性来暗示React这是同一个DOM结构，反之若key值不同则会被当做完全不同的DOM结构。

### 2. vue Diff

react和vue diff的区别：

   * vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。
   * vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性
   * vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个。总体上，vue的对比方式更高效。

vue平层Diff四种情况：

* REPLACE：节点类型变了，卸载旧节点装载新节点

* PROPS：节点类型一样，只是属性或属性值变了，此时只触发节点的更新

* TEXT：只是文本变了，直接修改文字内容

* REORDER：移动/增加/删除 子节点

### 3. vue和react的区别？

（1）model-view

​	vue是数据响应式，底层原理基于defineProperty或proxy

​	react是单向数据流，基于对setState方法的调用和

（2）

### 4. react/vue 生命周期？

#### react

react旧版生命周期

![](.\img\react旧版生命周期.png)

react新版生命周期

![](.\img\react新版生命周期.png)

### 5. 谈谈redux

#### (1). 设计思想

> 1. web应用是一个状态机，视图和状态时一一对应的
>
> 2. 所有的状态，都保存在一个对象里面

#### (2). 基本概念

**2.1 Store**

````javascript
import { createStore } from 'redux';
const store = createStore(fn);
````

**2.2 State**

````javascript
import { createStore } from 'redux';
const store = createStore(fn);
const state = store.getState();
````

**2.3 Action**

​	State的变化，一定会导致View的变化，而State的变化一定是用户的View操作导致的，而Action就是View发出的通知，表示State应该要发生变化了。

````javascript
const action = {
  type: 'ADD_TODO',
  payload: 'Learn Redux'
};
````

**2.4 Action Creator**

**2.5 store.dispatch()**

​	`store.dispatch() ` 是 View 发出 Action 的唯一方法。

````javascript
import { createStore } from 'redux';
const store = createStore(fn);

store.dispatch({
  type: 'ADD_TODO',
  payload: 'Learn Redux'
});

// 使用creator:
store.dispatch(addTodo('Learn Redux'));
````

**2.6 Reducer**

​	Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。

​	Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。

```javascript
const defaultState = 0;
const reducer = (state = defaultState, action) => {
  switch (action.type) {
    case 'ADD':
      return state + action.payload;
    default: 
      return state;
  }
};
// 手动调用reducer
const state = reducer(1, {
  type: 'ADD',
  payload: 2
});
```

实际应用中，Reducer 函数不用像上面这样手动调用，`store.dispatch`方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入 `createStore` 方法。

**2.7 store.subscribe()**

Store 允许使用`store.subscribe`方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。显然，只要把 View 的更新函数（对于 React 项目，就是组件的`render`方法或`setState`方法）放入`listen`，就会实现 View 的自动渲染。

```javascript
import { createStore } from 'redux';
const store = createStore(reducer);

store.subscribe(listener);
```

`store.subscribe`方法返回一个函数，调用这个函数就可以解除监听。

#### (3). 异步和中间件

**3.1 redux-thunk**

异步操作至少要送出两个Action：请求的异步Action和触发更新的同步Action，可以使用一个Action Creator依次执行这两个action，但最终返回的一定是一个函数而不是一个对象，但dispatch又不能接受函数，所以要使用redux-thunk中间件，使得dispatch可以接受函数作为参数

**3.2 redux-promise**

同thunk，如果想给dispatch返回的是一个promise对象，使用这个中间件

### 6. 为什么原生js操作的dom消耗很大，为什么虚拟DOM可以减少dom操作？

原生js操作dom：

* 【从头到尾】原生js操作DOM时，浏览器会从构建DOM树开始从头到尾更新一遍

* 【多次更新分开执行】有10个节点需要更新时，浏览器会分别进行10次从头到尾的dom更新，而不会合并为一次

* 【dom更新会导致前一次计算的结果无效】第一次计算完，下一个DOM更新请求，前一个节点的坐标值可能就变了，实际上前面几次都是无用功

虚拟DOM：

* 如果一次操作有多次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将十次更新的diff内容保存在一个js对象中，再进行后续的操作，避免无谓的计算量。同时在JS对象中对更新的计算肯定比DOM操作更快，最终将js对象映射成真实的DOM交给浏览器绘制

  **实现虚拟DOM** https://www.jianshu.com/p/af0b398602bc

### 7. 谈谈虚拟DOM

* 性能提升+跨平台/服务端渲染

* 构建虚拟dom对象

* diff算法

* 映射成真实的dom（使用了DOM fragment来一次更新DOM）

  **dom fragment** https://www.webhek.com/post/javascript-documentfragment.html

### 8. 谈谈react Fiber

https://zhuanlan.zhihu.com/p/26027085

需要解决的问题：

* 页面元素很多，需要频繁刷新的时候，由于大量的同步渲染事件阻塞了鼠标/键盘事件和浏览器的UI渲染，导致页面卡顿

实现方式：

react框架主要包含：VDOM层，Reconciler层，Renderer层，Fiber主要改动在Reconciler层，在Fiber Reconciler中，操作被分割成了很多小部分，并且可以被中断，每一个拆分的最小工作单元就是一个fiber对象。Fiber 树在首次渲染的时候会一次过生成。在后续需要 Diff 的时候，会根据已有树和最新 Virtual DOM 的信息，生成一棵新的树。这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行。如果没有，则继续构建树的过程：如果过程中有优先级更高的任务需要进行，则 Fiber Reconciler 会丢弃正在生成的树，在空闲的时候再重新执行一遍。

可以理解为，原先react组件渲染的同步任务是连贯的，持续占用主线程，Fiber使得每个组件的生命周期中都可以被打断，执行其他任务

问：Fiber使得生命周期会被中断，会不会产生页面渲染到一半被中断导致页面表现出错的bug？

答：不会，Fiber Reconciler执行分为两个阶段

​		(1) 一阶段：生命周期中的 componentWillMount、componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate属于这一阶段，这一阶段可以被打断

​		(2) 二阶段：生命周期中的 componentDidMount、componentDidUpdate、componentWillUnmount处于这一阶段，这个阶段将当前组件中需要更新的节点一次性批量更新，这个过程不能被打断

**从栈协调器到Fiber协调器**

###  9. 谈谈react hooks

### 10. react Refs

### 11. 谈谈flutter

### 12. 谈谈redux中间件

https://www.jianshu.com/p/ae7b5a2f78ae

### 13. setState() 是同步的还是异步的？

* 在**原生事件和setTimeout**中是**同步**的，在react库的调用中（比如**钩子函数和合成事件**）是**异步**的。
* setState具有**批量更新优化**特点，如果在异步队列中出现了对同一个值的多次setState，会只取最后一次的执行，如果出现了对多个值的更新，会合并这些过程为一次更新
* 其异步的**原理**在于，钩子函数的调用顺序在更新之前，因此没法立即拿到更新后的值，形成了所谓的异步

````javascript
	this.setState({ count: this.state.count + 1 });
    console.log("console: " + this.state.count); // 0
    this.setState({ count: this.state.count + 1 }, () => {
      console.log("console from callback: " + this.state.count); // 2
    });
    this.setState(prevState => {
      console.log("console from func: " + prevState.count); // 1
      return {
        count: prevState.count + 1
      };
    }, ()=>{
      console.log('last console: '+ this.state.count)
    });

// 执行结果：
// console: 0 
// console from func: 1 
// console from callback: 2
// last console: 2 
````

````javascript

class App extends Component {
  state = {
    count: 0
  };
 
  componentDidMount() {
    // 生命周期中调用
    this.setState({ count: this.state.count + 1 });
    console.log("lifecycle: " + this.state.count);
    setTimeout(() => {
      // setTimeout中调用
      this.setState({ count: this.state.count + 1 });
      console.log("setTimeout: " + this.state.count);
    }, 0);
    document.getElementById("div2").addEventListener("click", this.increment2);
  }
 
  increment = () => {
    // 合成事件中调用
    this.setState({ count: this.state.count + 1 });
    console.log("react event: " + this.state.count);
  };
 
  increment2 = () => {
    // 原生事件中调用
    this.setState({ count: this.state.count + 1 });
    console.log("dom event: " + this.state.count);
  };
 
  render() {
    return (
      <div className="App">
        <h2>couont: {this.state.count}</h2>
        <div id="div1" onClick={this.increment}>
          click me and count+1
        </div>
        <div id="div2">click me and count+1</div>
      </div>
    );
  }
}
````

### 14. 为什么react创建类的时候，要在构造函数中为函数绑定this？

   把原型方法`handleClick( )`改变为实例方法`handleClick( )`,并且强制指定这个方法中的`this`指向当前的实例。
   如果不绑定this，试图调用方法操作该组件实例的state时，就会出错，因为该方法仍然是原型方法，this没有指向该对象实例，自然也就获取不到state

### 15. 合成事件和原生事件

合成事件的event对象只在当前event loop有效，比如在事件中调用一个promise，在resolve之后去获取event对象会获取不到

### 16. 前端路由的原理

核心问题：

* 如何改变URL而不引起页面刷新

  hash/history

* 如何检测URL变化

  hash：监听hashchange事件

  history：监听popstate事件以及<a>标签的变化

#### hash

hash是URL中hash(#)及后面的部分，常用作锚点在页面内进行导航，改变hash不会引起页面刷新

可以通过**hashchange**事件监听URL变化。URL变化的方式：浏览器前进后退/通过<a>标签改变URL、通过window.location改变URL

#### history

history提供了pushState和replaceState两种方法，改变的是URL的path部分，不会引起页面的刷新

通过**popstate**事件监听URL变化。浏览器进退可以监听到，但a标签变化和pushState及replaceState方法不会触发popState事件

https://www.cnblogs.com/lguow/p/10921564.html

### 17. 谈谈React-Redux

概念：

* UI组件：负责UI呈现
* 容器组件：负责数据和逻辑

如果一个组件既有UI逻辑又有业务逻辑怎么办？用一个Provider组件包一个UI组件

* connet()：负责将这两种组件连起来

```javascript
import { connect } from 'react-redux'

const mapStateToProps = (state) => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}

const mapDispatchToProps = (
  dispatch,
  ownProps
) => {
  return {
    onClick: () => {
      dispatch({
        type: 'SET_VISIBILITY_FILTER',
        filter: ownProps.filter
      });
    }
  };
}

const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList)

```

### 18. React中跨组件传参有哪些方案？它们有哪些优劣？





## 五、工程化

### 1. 谈谈webpack的原理

https://juejin.cn/post/6844904094281236487

webpack构建流程
(1) 初始化参数，从配置文件和shell语句中读到的参数合并，得到最后的参数
(2) 开始编译：用合并得到的参数初始化complier对象，加载所有配置的插件，执行run方法开始编译
(3) 确定入口，通过entry找到入口文件
(4) 编译模块，从入口文件出发，调用所有配置的loader对模块进行解析翻译，在找到该模块依赖的模块进行处理
(5) 完成模块编译，得到每个模块被翻译之后的最终的内容和依赖关系
(6) 输出资源，根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，在把每个chunk转换成一个单独的文件加载到输出列表
(7) 输出完成，确定输出的路径和文件名，把内容写到文件系统中
 在以上过程中，webpack会在特定的时间点广播出特定的事件，插件在监听感兴趣的事件后会执行特定的逻辑，改变webpack的运行结果

### 2. webpack的loader和plugin有什么区别

loader是一个加载器，最重要的是使webpack拥有加载和解析非js文件的能力。例如，将A文件编译成B文件，例如将A.scss编译成A.css

plugin是一个扩展器，处理的是webpack生命周期中广播出的许多事件，执行广泛的任务

#### loader

* css-loader/style.loader：webpack是运行在nodejs环境中的，所以默认webpack打包只会处理JS间的依赖关系，需要cssloader来导入css
* postcss-loader：添加浏览器前缀、压缩CSS
* less-loader
* babel-loader

#### plugin

* html-webpack-plugin

  可以动态配置html，可用于配置cdn

* optimizi-css-assets-webpack-plugin：压缩项目css资源

* webpack-dev-server

* clean-webpack-plugin：编译前清理输出目录

* CopyWebpackPlugin：复制文件

* HotModuleReplacementPlugin：热更新

* ProvidePlugin：全局变量设置

* DefinePlugin：定义全局常量

* splitChunks（老版本用CommonsChunkPlugin）：提取公共模块，将符合引用次数的模块打包到一起

* mini-css-extract-plugin（老版本用ExtractTextWebpackPlugin）：css单独打包

* TerserPlugin（老版本用UglifyJsPlugin）：压缩代码

* progress-bar-webpack-plugin：编译进度条

* DllPlugin& DllReferencePlugin：提高打包效率，仅打包一次第三方模块

* webpack-bundle-analyzer：可视化的查看webpack打包出来的各个文件体积大小

* thread-loader,happypack：多进程编译，加快编译速度
* **webpack-dashboard**：展示打包相关信息
* **speed-measure-webpack-plugin**：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈

### 3. webpack-dev-server

热加载基本思路：监听本地文件修改，服务器推送到客户端，执行更新

webpack从module bundler角度来实现热加载，构建bundle的时候，加入一段HMR runtime的js和一段和服务沟通的js，文件修改触发webpack重新构建，服务器通过向浏览器发送更新消息，浏览器通过jsonp拉取更新的模块文件，jsonp回调触发热替换逻辑

https://blog.csdn.net/sinat_17775997/article/details/83662133

https://github.com/webpack/docs/wiki/hot-module-replacement-with-webpack#how-does-it-work

### 4. less、scss和css有什么区别

### 5. 谈谈Webpack打包加速优化

开发环境中不做多余的事，例如代码压缩，目录清理，计算文件hash

可以通过外链引入第三方库

开启热更新

DllPlugin& DllReferencePlugin：动态链接库，提高打包效率，仅打包一次第三方模块，每次构建只重新打包业务代码。

tree shaking 压缩阶段开启静态检查

多线程编译

开启缓存（loader缓存，wpa架构缓存）

### 6. 谈谈Webpack打包体积优化

压缩插件

服务端开启gzip

雪碧图

...

### 7.你知道sourceMap是什么吗（webpack）

`sourceMap`是一项将编译、打包、压缩后的代码映射回源代码的技术，由于打包压缩后的代码并没有阅读性可言，一旦在开发中报错或者遇到问题，直接在混淆代码中`debug`问题会带来非常糟糕的体验，`sourceMap`可以帮助我们快速定位到源代码的位置，提高我们的开发效率。`sourceMap`其实并不是`Webpack`特有的功能，而是`Webpack`支持`sourceMap`，像`JQuery`也支持`souceMap`。





## 六、性能优化

### 1. cdn加速

CDN，即内容分发网络，当用户访问有CDN服务的网站时，首先通过DNS重定向技术（DNS协议在应用层）确定最接近用户的最佳CDN节点，同时将用户的请求指向该节点

* 负载均衡技术：将网络的流量尽可能均匀分配到几个能完成相同任务的服务器或者网络节点上
* 动态分发与复制技术：将网站主体的大部分静态网页、图像和图流体数据分发复制到各地的加速节点上，以供各地的用户能访问到最近节点的资源
* 缓存技术：缓存主站的静态资源，用户访问资源时如果资源没有过期就可以直接返回资源

### 2. 服务端渲染

### 3. 谈谈你页面渲染的优化方案（一般是cdn/服务端渲染和雪碧图之类的效果最明显）

> https://www.cnblogs.com/xiaohuochai/p/9178390.html

#### 基础款

1. 图片加载：懒加载/雪碧图

2. 代码运行时优化：

   css/选择器/组件嵌套层级

   react迭代组件加key

   页面里很少变动的用v-if，变动的多的用v-show（if切换时性能差，show加载时性能差）

   v-if和v-for不要同用 / 使用computer

3. cdn加速，服务端渲染

4. 代码压缩（webpack模块打包，如gzip压缩）

* 把js放在body最后加载，调整js文件的加载顺序，拆分js文件，减少特大js文件的加载速度
* vue在渲染迭代对象时尽量使用key，可以提高vue的diff算法效率；用item自身的id而不是index，否则颠倒顺序之后，index完全不同，则会视为不同的组件重新渲染
* 在react中，通过表单事件触发的state更新也会触发render，可以通过shouldComponentUpdate来避免

#### 进阶款

1. 减少请求数量

   雪碧图、合并请求、减少重定向

2. 减小资源大小

3. 优化网络连接

4. 优化资源加载

   脚本顺序及位置

   模块按需加载

5. 减少重绘回流

6. 性能更好的api

7. webpack优化

### 4. 谈谈v-if和v-show

v-if通过返回值判断是否加载或删除这个节点，v-show是通过display属性来控制是否渲染这个节点

**if切换时性能差，show加载时性能差**

   * if会转换成一个三元表达式来决定是否创建或销毁一个vnode，userProfile也会跟着操作，如果组件里有大量DOM节点，就会执行过多DOM操作。而show是通过切换display来实现的，组件还是会渲染。

   * 使用keep-alive可以创建组件缓存，结合if一定程度上既能保证首屏加载快又能切换不浪费资源

v-if和v-for不要同用，如果需要判断子组件是否需要渲染，使用computer进行filter

diff:多用key，用item自身的id而不是index，否则颠倒顺序之后，index完全不同，则会视为不同的组件重新渲染

https://blog.csdn.net/grandpang/article/details/51329289

### 5. 移动端优化

https://segmentfault.com/a/1190000005882953

1. 静态文件内联

2. 使用localStorge缓存页面

   cookie携带localStorge中的版本号（MD5戳），判断是否需要拉取最新版本号（类似于协商缓存中校验文件hash码）

3. 合并外链请求，缓存到localStorge中

4. 小图片base64化

### 6. WEB安全

**脚本注入-XSS攻击防御策略：**

(1) 给cookie携带"httpOnly"头部

(2) 字符转义

**跨站请求伪造-CSRF防御：**

(1) 黑客利用img-src发起get请求跨域——关键业务不使用get

(2) 黑客利用隐藏form表单骗取点击事件同样可以进行post跨域请求——

​	设置验证码，或种上token

https://segmentfault.com/a/1190000006672214



## 七、CSS基础

### 1. margin坍缩：如果父元素没有设置上内边距或上边框，子元素的上边距就会和父元素的上边距重合

   **解决方法：让父元素触发BFC，如：float/position:absolute/overflow:hidden/display:inline-block**

   margin合并：上下两个元素相接触的margin重合

### 2. 谈谈BFC

> https://blog.csdn.net/sinat_36422236/article/details/88763187

BFC：块级格式化上下文，在一个BFC中，其元素布局不受外界的影响，且在BFC中，块盒与行盒都会垂直地沿着其父元素的边框排列

#### (1). 布局规则

* box会在垂直方向一个接一个放置
* 垂直方向地距离由margin决定，属于同一个BFC地相邻box的margin会发生重叠
* 每个盒子的margin box的左边，与包含块border box的左边相接触
* BFC不会和float box重叠
* 计算BFC高度时，float元素也参与计算

#### (2). 如何创建BFC

* float不为none
* overflow不为visible
* position不为static或relative
* display为inline-block、flex、table-cell、table-caption或inline-flex

#### (3). 应用

1. 防止margin重叠

   由于BFC内部会发生margin重叠，所以将两个重叠元素外部都包裹一个BFC，就不会发生重叠了

2. 浮动元素与块状元素自适应两栏布局

   因为浮动元素和BFC不会重叠，所以让右侧元素成为BFC，就可以自适应了

3. 子元素为浮动元素且父元素未设置高度时，父元素会发生高度塌陷

   此时为父元素激活BFC即可

### 3. display:none 和 visibility: hidden的区别

display：none的元素不会出现在render树，但是dom树上还是存在的，否则无法响应事件。
display：none后无论怎么修改子元素的display，都没用，因为根本不在render树中。

hidden的元素依旧会占位，只是看不到。子元素修改visilibilty: visible；是可以显现的，这个结果也正常，毕竟hidden的元素依旧存在于render树。

### 4. 如何设置一个div(视频)不管在什么设备及父元素环境下，始终以4：3的比例缩放

#### (1) 图片默认的按比例缩放机制

如果只设置图片的一个宽或高，另一个值就会按照图片真实的比例缩放。

#### (2) 对于div/视频的解决思路

当父容器height为0时，padding-bottom设置为百分比时，其高度会自动按宽度的比例缩放

````css
.wrap {
    height: 0;
    padding-bottom: 75%; /* 16:9 设计稿的：高/宽*100%*/
    position: relative;
    width: 100%;
    background-color: #1733ff;
}
.wrap box {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
}
````

### 5. 图片懒加载

> 参考 https://zhuanlan.zhihu.com/p/55311726

相关api

```js
document.documentElement.clientHeight //获取屏幕可视区域的高度
element.offsetTop //获取元素相对于文档顶部的高度
document.documentElement.scrollTop //获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离
```

![](.\img\浏览器可视区域.jpg)

如果：offsetTop-scroolTop<clientHeight，则图片进入了可视区内，则被请求。



### 6. 垂直居中

#### (1). absolute+transform（不用知道高度）

````css
parent {
    position: relative;
}
child {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}
````

#### (2). 如果父元素下只有这一个子元素，且父元素有高度

````css
parent {
    height: xxx;
}
child {
	position: relative;
    top: 50%;
    transform: translateY(-50%);
}
````

#### (3). 需要知道子元素的高度

````css
child {
	position: absolute;
	width: 100px;
	height: 200px;
	top: 50%;
	margin-top: -100px
}
````

#### (4). Flex

```css
parent {
    display: flex;/*Flex布局*/
    display: -webkit-flex; /* Safari */
    align-items:center;/*指定垂直居中*/
}
```

#### (5). line-height

行内元素适用

### 7. rem

>  参考 https://zhuanlan.zhihu.com/p/30413803
>
>  html 字体的默认大小是16px

rem是相对于根元素字体的大小，em是相对于父元素的大小

rem取值的两种情况：

```css
/* 作用于根元素，相对于原始大小（16px），所以html的font-size为32px*/
html {font-size: 2rem}

/* 作用于非根元素，相对于根元素字体大小，所以为64px */
p {font-size: 2rem}
```

将html字体大小设置为屏幕宽度的百分之一，那么1rem就等于屏幕宽度的百分之一了

```css
html {fons-size: 1vw} /* 1vw = width / 100 */
p {width: 15.625rem}
```

rem实现的其实就是vw，但是兼容性比vw好

### 8. px

移动端如何实现1px？

> 参考 https://www.cnblogs.com/lhb25/p/seven-method-for-1px-retina-screen.html

1. border-shadow

```css
   .box-shadow-1px {
     box-shadow:  inset 0px -1px 1px -1px #c8c7cc;
   }
```

2. 0.5px

3. border-image/background-image

4. viewport+rem

5. 伪类+transform:scaleY(0.5)

 ```
   .scale-1px{
     position : relative;
     border :none;
   }
   .scale-1px:after{
    content: '';
    position: absolute;
    bottom: 0;
    background: #000;
    width: 100%;
    height: 1px;
    -webkit-transform: scaleY(0.5);
    transform: scaleY(0.5);
    -webkit-transform-origin: 0 0;
    transform-origin: 0 0;
   }
 ```







## 八、一些新的API

### 1. requestAnimationFrame() —— 实现动画循环

#### (1). 早期动画循环 - setInterval()

````js
(function() {
	function updateAnimation() {
		doAnimation1()
		doAnimation1()
	}
	setInterval(updateAnimations, 100)
})()
````

但是存在浏览器的计时器间隔实现问题，最快的chrome也至少为4ms

#### (2). mozRequestAnimationFrame

````js
function draw(timestamp) {
	// 计算两次重绘的时间间隔
	var diff = timestamp - startTime
	// 使用diff确定下一步的重绘时间
	// 把startTime重写为这一次的绘制时间
    startTime = timestamp
    mozRequestAnimationFrame(draw)
}

var startTime = mozAnimationStartTime
mozRequestAnimationFrame(draw)
````

#### (3). webkitRequestAnimationFrame、msRequestAnimationFrame

````js
(function() {
    function draw(timestamp) {
        // 计算两次重绘的时间间隔
        var drawStart = (timestamp || Date.now())
            diff = drawStart - startTime
        // 使用diff确定下一步的重绘时间
        // 把startTime重写为这一次的绘制时间
        startTime = drawStart
        RequestAnimationFrame(draw)
    }

    var requestAnimationFrame = window.requestAnimationFrame ||
                                window.mozRequestAnimationFrame || 
                                window.webkitRequestAnimationFrame || 
                                window.msRequestAnimationFrame,
        startTime = window.mozAnimationStartTime || Date.now()
    requestAnimationFrame(draw)
})()
````

### 2. Page Visibility

### 3. File API

### 4. Web Workers

## 九、 DOM、BOM

### 1. 浏览器解析http文档的执行顺序

(1) 访问url后

1. browser下载html页面
2. browser解析DOM结构
3. 开启下载线程，按优先级下载

(2) 进入<head>

1. 遇到js，停止后续解析，完成下载后立即执行；

   遇到css，继续解析，下载完成构建cssom

(3) 进入<body>

1. 只有DOM，DOM树构建完成，页面完成首次渲染

2. dom和js，若js未下载，在渲染已经解析的DOM树和cssom，同时阻止后续dom树创建

3. dom和css，css不会打断dom树创建，但会阻止渲染，外链css加载完成前，页面仍然是白屏

4. dom css 和js，js和css会阻塞页面渲染

   等到css加载完成后，dom树和cssom合并渲染树

   **（因此js放在css后加载，可以更快地生成渲染树）**

(4) 完成解析

1. 文档解析完毕，页面重新渲染，所有js**同步**代码执行完毕，触发**DOMContentLoaded**
2. html文档中img，js代码中异步css js完毕后，触发load

#### 总结

* css 不会阻塞 dom 的解析，但是会阻塞 dom 的渲染
* js 阻塞 dom 的解析，但是浏览器会偷看 dom，预先下载相关资源
* 浏览器遇到 <script> 且没有 defer 或 async 属性的标签时，会触发页面渲染，因而如果前面 css 资源尚未加载完毕时，浏览器会等待它加载完毕再执行脚本

**更详细的解析**：https://juejin.cn/post/6844903497599549453

### 2. 回流 重绘

减少重绘回流

#### CSS

1. 直接改变className而非style，尽可能在DOM树最末端改变class
2. 避免使用table
3. 需要多次重排的元素，设置为absolute和fixed，这样元素就脱离了文档流
4. 使用display: none，只发生两次回流和重绘

#### JS

1. 避免频繁操作样式
2. 不要经常访问会引起浏览器缓存队列的属性(上述那些浏览器会立刻清空队列的属性)，例如offsetLeft，如果确实需要，就用变量先缓存起来
3. 尽量合并DOM操作/使用documentFragment

## 十、移动端

### 1. 分辨率

[探究移动端viewpoint](https://juejin.cn/post/6862158858341580808)

https://segmentfault.com/a/1190000005884985

`<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">` 这一行是什么意思？——

viewport是设备屏幕上能够显示网页的区域。

width = device-width 表示当前的viewport等于设备的宽度

initial-scale = 1.0 表示页面的初始缩放值为1

maximum-scale = 1.0 表示允许用户的最大缩放值为1

user-scalable = 0 表示不允许用户缩放

[使用vw和vh实现流体排版](https://www.cnblogs.com/wengxuesong/archive/2016/05/16/5497653.html)



### 2.



## 其他面经参考

1. 常见面试问题，写得非常非常清晰 https://github.com/febobo/web-interview

