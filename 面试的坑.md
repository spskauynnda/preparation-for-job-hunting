# 面试的坑

## 一、网络基础

### 1. tcp/udp

### 2. tcp三次握手四次挥手

### 3. 状态码

### 4. http和https的区别

### 5. http是基于tcp的还是基于udp的

​	http2.0之前基本上都基于tcp，因为http需要建立可靠连接

​	http3.0谷歌选择在udp的基础上进行改造，兼容http2.0的同时进一步解决响应慢的问题

​	quic解决了以下几个问题

* **队头阻塞问题**（HTTP层队头阻塞和TCP层队头阻塞。http2.0多路复用解决了队头阻塞，但tcp层还存在阻塞）

  TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。

  QUIC协议是基于UDP协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。

* **0 RTT建链**

  一般来说HTTPS协议要建立完整链接包括:TCP握手和TLS握手，总计需要至少2-3个RTT，普通的HTTP协议也需要至少1个RTT才可以完成握手。

  然而，QUIC协议可以实现在第一个包就可以包含有效的应用数据，从而实现0RTT，但这也是有条件的。

  首次连接使用DH密钥交换算法。

* **前向安全**

  前向安全或前向保密Forward Secrecy是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。

* **前向纠错**

* **连接迁移**

### 6. 从url到页面加载经历的过程

​	https://blog.csdn.net/qq_42033567/article/details/107414221

  (1) DNS解析

  * 浏览器缓存解析/操作系统缓存解析/本地DNS服务器解析/其他DNS服务器解析(根、顶级、其他)

  * 将结果缓存，返回给浏览器

  * 向本地DNS服务器递归查询，向其他DNS服务器迭代查询

  (2) 发起TCP连接

  * 三次握手

  a. SYN = 1    seq = x

  b. ACK = 1    SYN = 1    ack = x+1    seq = y

  c. ACK = 1    ack = y+1

  (3) 客户端发起HTTP请求

  * 请求报文：请求行+请求头+空行+消息体

  (4) 服务端接受HTTP请求，返回HTTP响应

  * 响应报文：状态行+响应头+空行+消息体

  (5) 结束TCP连接

  * 四次挥手

​		a. FIN = 1    ack = z    seq = X

​		b. ACK = x+1    seq = z

​		c. FIN  = 1    ack = X    seq = Y

​		d. ACK = Y    Seq = X

(6) 收到请求，解析渲染页面

  * 解析HTML，构建DOM树
  * 解析CSS，构建CSSOM树
  * 合并DOM和CSSOM树，生成render树
  * **回流**，计算布局
  * **重绘**，将布局渲染到屏幕上

### 7. 强缓存 弱缓存

### 8.http各个版本的区别

### 9. 滑动窗口

### 10. 拥塞控制

## 二、js基础

### 1. apply/call/bind

* 共同点：都是用来重定义this对象的

  objA.foo.call(ObjB, ...) 

  objA.foo.apply(ObjB, ...)

  **objA.foo.bind(ObjB, ...)()**

* 区别1：call和apply返回的是foo方法的返回值，bind返回的是一个新函数

* 区别2：

  (1) 使用call时，后续参数**以逗号分割**传入被调用的函数中

  (2) 使用apply时，后续输入参数必须放在一个**数组**中传入

  (3) bind**返回是函数**，传入参数和call一样

* 用途——react中的bind

  **类的方法默认不会绑定this，如果忘记绑定，则传入函数名并调用时，this值会是undefined**

  解决方法：bind或箭头函数

  1. 在构造函数constructor 内绑定`this.handleClick = this.handleClick.bind(this)`
  2. `handleClick = () => { ... }`
  3. 
	
    	handleClick ( ) { ... }
    	
    	render() {
    		return (
    	 		<button onClick={(e) => this.handleClick(e)}> ...
    	 		</button>
    		 )
    	}
  
* **手写bind** https://blog.csdn.net/q3254421/article/details/82999718

### 2. 原型链

![image-20210318200848599](.\img\原型链文字总结.png)

### 3. 闭包

可以参考 https://segmentfault.com/a/1190000002778015

**定义**：一个函数**有权**调用另一个函数作用域内的变量，被内部函数访问的外部函数的变量可以保存在外部函数作用域内而**不被回收**。最常见的就是一个函数内部创建另一个函数，调用外部函数的变量。

（市面上的面试题把闭包诠释得很复杂，又是自执行的匿名函数，又是同步异步的，这些知识本质上是需要区分开来理解的）

最简单的例子：

   ````
   var sayName = function(){
       var name = 'jozo';
       return function(){
           alert(name);
       }
   };
   var say = sayName(); 
   say();
   ````

**缺点**：通常来说，js在混合编译的V8引擎下，不再被调用的变量会被垃圾回收(**GC**)机制清除。但是！如果创建了闭包，那被闭包调用的外部变量就会被长期保存在内存中，造成空间占用甚至内存泄漏

**场景1**：一个最经典的面试题就是使用闭包解决for循环中循环变量的异步调用问题，例如

   ````
   for ( var i=0; i<5; i++) {
       setTimeout( function timer() {
       	console.log( i );
       }, 0 );
   }
   // 5 5 5 5 5
   ````

   这个例子涉及作用域以及 **事件循环机制（Event Loop）**中的同步和异步队列的调用顺序问题，由于setTimeout属于异步宏任务，js引擎会先把同步任务执行完毕再执行异步任务。而又由于for循环本身不构成块级作用域，用var定义的循环变量实际上不是定义在for循环内，而是定义在for所处的作用域（即外部环境）内，导致for循环执行完才会执行setTimeout函数，此时的i为5，所以输出5个5

解决这个问题除了弥补for循环无法创建块级作用域的不足->使用let来声明变量以外，就得使用闭包了

   ````
   for (var i = 1; i <= 5; i++) {
       (function(j) {
           setTimeout(function timer() {
           	console.log(j);
           }, 1000);
       })(i);
   }
   ````

   这里的所谓闭包，就是使用一个自执行的匿名函数`(function(){...})(i)`，在每层循环中都创建一个内部的作用域，将变量i保存下来

   **场景2**：使用闭包可以包装函数，减少函数使用时所需要传入的参数（**函数柯里化**），或是隐藏一些私有变量

   ````
   // 普通的add函数
   function add(x, y) {
       return x + y
   }
   
   // Currying后
   function curryingAdd(x) {
       return function (y) {
           return x + y
       }
   }
   
   add(1, 2)           // 3
   curryingAdd(1)(2)   // 3
   ````

### 4. 匿名函数

【重点】非严格模式下，this指向window，严格模式下，this指向undefined。同时匿名函数是一个没有指针的全局变量，通过window并不能找到这个匿名函数，这种调用具有安全性和隐匿性。

并非匿名函数本身特殊，而是Property accessor语法影响了this。

先看**一般情况**，在运行 `obj.foo()` 时，根据属性访问语法，函数会调用运算符"()"的左边部分，获取一个base为obj的referenceType，然后进行函数调用运算，则referenceType.base会为该函数执行环境的this提供引用。

如果要消除referenceType带来的影响，很简单，`(1,obj,foo)()`就行了，因为分组运算符的加入，导致提前对referenceType进行了getValue操作，直接拿到函数对象进行函数调用运算，导致提供给该函数的执行环境关联的this值为null，在ES3中，规定此时glabal为this，而ES5的严格模式则修正了这一规则

外层分组运算符的作用是让 匿名函数表达式合法. 因 javascript 语法限制. 禁止函数表达式中, function 关键字出现在表达式的第一个token位置. so. 必须借助其他辅助语法来完成所谓匿名函数的立即调用..比如 赋值表达式,逗号运算等等。显然匿名函数解释执行的结果不是一个referenceType .但是规则中有表述,当不是referenceType时. 仍然把null (undefined-SE5) 作为this 提供给该函数执行环境.

完整问答链接：**匿名函数的this指向为什么是window?** https://www.zhihu.com/question/21958425/answer/19858492

### 5. Array.prototype.slice()

   Array.prototype.slice.call(arrLike)   等效于  [].slice.call(arrLike)   

   可用于将类数组对象arrLike转换为一个新数组

   ````
   // 类数组对象-字符串的表现
   const str = '1234'
   str.slice() // '1234'
   [].slice.call(str)  // ['1','2','3','4']
   function list1(item){ return [].slice.call(item) }
   function list2(){ return [].slice.call(arguments) }
   list1(str)     // ['1','2','3','4']
   list2(str)     // '1234'
   ````

   ```
   // mdn例子
   function list() {
     return Array.prototype.slice.call(arguments)
   }
   var list1 = list(1, 2, 3)  // [1, 2, 3]
   
   //使用bind"简化"list
   var unboundSlice = Array.prototype.slice
   var slice = Function.prototype.call.bind(unboundSlice)
   }
   function list() {
   	return slice(arguments)
   }
   var list2 = list(1,2,3)   // [1, 2, 3]
   ```

   ES6中Array.from()是该方法的新实现

### 6. 深拷贝浅拷贝

* Array.assign

  对象只有一层时为深拷贝，对象不止一层时为浅拷贝

* Array.create

* JSON.stringify

  ````
  let newObj = JSON.parse(JSON.stringify(obj))
  ````

  很简单对吧，缺点是不能复制undefined、RegExp和原型

* 手写深拷贝函数

    ````
    // 定义一个深拷贝函数  接收目标target参数
    function deepClone(target) {
        // 定义一个变量
        let result;
        // 如果当前需要深拷贝的是一个对象的话
        if (typeof target === 'object') {
        // 如果是一个数组的话
            if (Array.isArray(target)) {
                result = []; // 将result赋值为一个数组，并且执行遍历
                for (let i in target) {
                    // 递归克隆数组中的每一项
                    result.push(deepClone(target[i]))
                }
             // 判断如果当前的值是null的话；直接赋值为null
            } else if(target===null) {
                result = null;
             // 判断如果当前的值是一个RegExp对象的话，直接赋值    
            } else if(target.constructor===RegExp){
                result = target;
            }else {
             // 否则是普通对象，直接for in循环，递归赋值对象的所有值
                result = {};
                for (let i in target) {
                    result[i] = deepClone(target[i]);
                }
            }
         // 如果不是对象的话，就是基本数据类型，那么直接赋值
        } else {
            result = target;
        }
         // 返回最终结果
        return result;
    }
    ````

### 7. this指向

七条规则：参考掘金

(1) 箭头函数：箭头函数的this绑定在函数内部，不可修改

(2) new：使用new关键字构造的对象，其this指向生成的对象内部；不能使用箭头函数作为构造函数

(3) bind：Function.prototype.bind **多次bind时只取第一次**，与前两条规则同时出现时，服从于前两条规则

(4) call/apply：冲突时，服从于前三条

(5) obj.：

(6) **被直接调用**：除以上情况之外，被直接调用的时候，this将指向全局对象

````
function outerFunc(){
	console.log(this) // {x:1}
	function func() {
		console.log(this) // window
	}
	func()
}
outerFunc.bind({x:1})
````

​	setTimeout和匿名函数也属于此类情况

(7) 不在函数里：如果在<script/>标签里，指向Window，如果在Nodejs模块文件里，指向Module的默认导出对象

### 8. 作用域链

## 三、ES6

> 主要内容
> 1. 函数的默认参数
> 2. 反引号：模板表达式/多行字符串
> 3. 拆包表达式：var { house, mouse} = $('body').data() 
> 4. 数组解构运算：...
> 5. Promise对象
> 6. 块作用域、let、const
> 7. 类
> 8. 模块化（标准实现CommonJS）
> 9. 数据结构（Map、Set）
> 10. 新函数和数组方法，如includes

### 1. var，const，let的区别

   var声明变量可以重复声明，而let不可以重复声明

   var是不受限于块级的，而let是受限于块级

　　var会与window相映射（会挂一个属性），而let不与window相映射

　　var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错

　　const声明之后必须赋值，否则会报错

　　const定义不可变的量，改变了就会报错

　　const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错

### 2. 查找两个数组的重复项

   let arrX = arr1.filter((item)=>arr2.includes(item))

   **Array.filter(function(){return 表达式})** 返回满足Array中满足表达式的元素

   **Array.includes()** indexOf的姊妹，它只返回true/false

### 3. 数组去重

   const uniq = function(){

   ​	return Array.from(new Set(arguments[0]))

   }

   但是该方法对两个相同的对象可能无效，因为在比较的时候比较的是两个对象的名，即两个指针，哪怕两个深拷贝一样的对象，其地址也可能不同

### 4. Promise

   手写Promise https://zhuanlan.zhihu.com/p/144058361

   Promise规范 https://es6.ruanyifeng.com/#docs/promise

#### (1). 含义

Promise是ES6提出的**异步编程**解决方案，Promise简单来说是一个**容器**，保存着某个未来才会结束的事件，从语法上说，Promise是一个对象，从它**可以获取异步操作的消息**

对比：ajax/fetch/axios/async/await

Promise对象的两大特点：

1. 对象状态不受外界影响，只有异步操作的结果，才能决定当前是哪一种状态。三种状态：`pending` `fulfilled` `rejected`
2. 一旦状态改变，就不会再变，且任何时候都能得到这个结果。两种状态改变的可能：从 `pending` 变为 `fulfilled`，或从 `pending` 变为 `rejected`。状态一经改变，就凝固了，不会再变，一直保持这个结果，称为 `resolved（已定型）` 。之后再对这个Promise对象添加回调函数，也会立即得到这个结果。

缺点：第一，一旦创建，就无法中途取消。第二，如果不设置回调函数，Promise内部抛出的错误是不会反应到外部的。第三，处于pending状态时，无法得知目前进展到哪一个阶段。

#### (2). Promise对象是一个构造函数，用来生成Promise实例

基本用法：

````
const promise = new Promise(function(resolve, reject){
	if (/*异步操作成功*/) {
		resolve(data)
	} else {
		reject(error)
	}
})
````

````
promise.then(function(value) {
  /* success */
}, function(error) {
  /* failure */
});

// promise.then接受两个参数，分别是成功和失败时的回调函数
// 但是更推荐使用promise.catch来单独处理失败情况下的回调函数，写法更同步化，promise.catch某种意义上等同于promise.then({}, callback)，示例如下：

promise.then(function(value) {
  /* success */
})
promise.catch(function() {
  /* failur */
})
````





## 四、框架

### 1. 简述react底层原理：

   包含调和阶段（比较前后VirtualDOM的不同，动态更新不同的部分，其中主要涉及diff算法）和render阶段

   **react diff算法**——

   假如使用循环递归对节点进行依次对比，算法复杂度将达到 O(n^3) ，而使用diff算法可降低至O(n) 

   策略一（**tree diff**）：
    Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。——只进行同级比较

   策略二（**component diff**）：
    拥有相同类的两个组件 生成相似的树形结构，
    拥有不同类的两个组件 生成不同的树形结构。 ——不同类的React组件会被当做完全不同的DOM结构而被完全替换

   策略三（**element diff**）：
    对于同一层级的一组子节点，通过唯一id区分。 ——开发人员可以通过给Virtual DOM一个唯一的key属性来暗示React这是同一个DOM结构，反之若key值不同则会被当做完全不同的DOM结构。

### 2. vue和react的区别？

### 3. vue和react的diff算法区别

   * vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。
   * vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性
   * vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个。总体上，vue的对比方式更高效。

vue平层Diff四种情况：

* REPLACE：节点类型变了，卸载旧节点装载新节点
* PROPS：节点类型一样，只是属性或属性值变了，此时只触发节点的更新
* TEXT：只是文本变了，直接修改文字内容
* REORDER：移动/增加/删除 子节点

### 4. react/vue 生命周期？

### 5. redux？saga？

### 6. 为什么原生js操作的dom消耗很大，为什么虚拟DOM可以减少dom操作？

原生js操作dom：

* 【从头到尾】原生js操作DOM时，浏览器会从构建DOM树开始从头到尾更新一遍

* 【多次更新分开执行】有10个节点需要更新时，浏览器会分别进行10次从头到尾的dom更新，而不会合并为一次

* 【dom更新会导致前一次计算的结果无效】第一次计算完，下一个DOM更新请求，前一个节点的坐标值可能就变了，实际上前面几次都是无用功

虚拟DOM：

* 如果一次操作有多次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将十次更新的diff内容保存在一个js对象中，再进行后续的操作，避免无谓的计算量。同时在JS对象中对更新的计算肯定比DOM操作更快，最终将js对象映射成真实的DOM交给浏览器绘制

  **实现虚拟DOM** https://www.jianshu.com/p/af0b398602bc

### 7. 谈谈虚拟DOM

* 性能提升+跨平台/服务端渲染

* 构建虚拟dom对象

* diff算法

* 映射成真实的dom（使用了DOM fragment来一次更新DOM）

  **dom fragment** https://www.webhek.com/post/javascript-documentfragment.html

### 8. 谈谈react Fiber

https://zhuanlan.zhihu.com/p/26027085

需要解决的问题：

* 页面元素很多，需要频繁刷新的时候，由于大量的同步渲染事件阻塞了鼠标/键盘事件和浏览器的UI渲染，导致页面卡顿

实现方式：

react框架主要包含：VDOM层，Reconciler层，Renderer层，Fiber主要改动在Reconciler层，在Fiber Reconciler中，操作被分割成了很多小部分，并且可以被中断，每一个拆分的最小工作单元就是一个fiber对象。Fiber 树在首次渲染的时候会一次过生成。在后续需要 Diff 的时候，会根据已有树和最新 Virtual DOM 的信息，生成一棵新的树。这颗新树每生成一个新的节点，都会将控制权交回给主线程，去检查有没有优先级更高的任务需要执行。如果没有，则继续构建树的过程：如果过程中有优先级更高的任务需要进行，则 Fiber Reconciler 会丢弃正在生成的树，在空闲的时候再重新执行一遍。

可以理解为，原先react组件渲染的同步任务是连贯的，持续占用主线程，Fiber使得每个组件的生命周期中都可以被打断，执行其他任务

问：Fiber使得生命周期会被中断，会不会产生页面渲染到一半被中断导致页面表现出错的bug？

答：不会，Fiber Reconciler执行分为两个阶段

​		(1) 一阶段：生命周期中的 componentWillMount、componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate属于这一阶段，这一阶段可以被打断

​		(2) 二阶段：生命周期中的 componentDidMount、componentDidUpdate、componentWillUnmount处于这一阶段，这个阶段将当前组件中需要更新的节点一次性批量更新，这个过程不能被打断

###  9. 谈谈react hook

### 10. 谈谈flutter

### 11. 谈谈redux中间件

https://www.jianshu.com/p/ae7b5a2f78ae

### 12. setState() 是同步的还是异步的？

* 在**原生事件和setTimeout**中是**同步**的，在react库的调用中（比如**钩子函数和合成事件**）是**异步**的。
* setState具有**批量更新优化**特点，如果在异步队列中出现了对同一个值的多次setState，会只取最后一次的执行，如果出现了对多个值的更新，会合并这些过程为一次更新
* 其异步的**原理**在于，钩子函数的调用顺序在更新之前，因此没法立即拿到更新后的值，形成了所谓的异步

````
	this.setState({ count: this.state.count + 1 });
    console.log("console: " + this.state.count); // 0
    this.setState({ count: this.state.count + 1 }, () => {
      console.log("console from callback: " + this.state.count); // 2
    });
    this.setState(prevState => {
      console.log("console from func: " + prevState.count); // 1
      return {
        count: prevState.count + 1
      };
    }, ()=>{
      console.log('last console: '+ this.state.count)
    });

// 执行结果：
// console: 0 
// console from func: 1 
// console from callback: 2
// last console: 2 
````

````

class App extends Component {
  state = {
    count: 0
  };
 
  componentDidMount() {
    // 生命周期中调用
    this.setState({ count: this.state.count + 1 });
    console.log("lifecycle: " + this.state.count);
    setTimeout(() => {
      // setTimeout中调用
      this.setState({ count: this.state.count + 1 });
      console.log("setTimeout: " + this.state.count);
    }, 0);
    document.getElementById("div2").addEventListener("click", this.increment2);
  }
 
  increment = () => {
    // 合成事件中调用
    this.setState({ count: this.state.count + 1 });
    console.log("react event: " + this.state.count);
  };
 
  increment2 = () => {
    // 原生事件中调用
    this.setState({ count: this.state.count + 1 });
    console.log("dom event: " + this.state.count);
  };
 
  render() {
    return (
      <div className="App">
        <h2>couont: {this.state.count}</h2>
        <div id="div1" onClick={this.increment}>
          click me and count+1
        </div>
        <div id="div2">click me and count+1</div>
      </div>
    );
  }
}
````

### 13. 为什么react创建类的时候，要在构造函数中为函数绑定this？

   把原型方法`handleClick( )`改变为实例方法`handleClick( )`,并且强制指定这个方法中的`this`指向当前的实例。
   如果不绑定this，试图调用方法操作该组件实例的state时，就会出错，因为该方法仍然是原型方法，this没有指向该对象实例，自然也就获取不到state

## 五、工程化

### 1. 谈谈webpack的原理

### 2. webpack的loader和plugin有什么区别

## 六、性能优化

### 1. cdn加速

CDN，即内容分发网络，当用户访问有CDN服务的网站时，首先通过DNS重定向技术（DNS协议在应用层）确定最接近用户的最佳CDN节点，同时将用户的请求指向该节点

* 负载均衡技术：将网络的流量尽可能均匀分配到几个能完成相同任务的服务器或者网络节点上
* 动态分发与复制技术：将网站主体的大部分静态网页、图像和图流体数据分发复制到各地的加速节点上，以供各地的用户能访问到最近节点的资源
* 缓存技术：将内容存储在ISP的缓存器中

### 2. 服务端渲染

### 3. 谈谈你页面渲染的优化方案（一般是cdn/服务端渲染和雪碧图之类的效果最明显）

（最常用的四个：使用react/vue的路由方案来切换页面，避免白屏渲染，我们是一个一个html的，没办法只能通过url触发页面切换，没法做；cdn加速/服务端渲染，这两个不适用于招办的离线环境；雪碧图，这个只适用于对图片加载的优化）

* 把js放在body最后加载，调整js文件的加载顺序，拆分js文件，减少特大js文件的加载速度

* vue在渲染迭代对象时尽量使用key，可以提高vue的diff算法效率；用item自身的id而不是index，否则颠倒顺序之后，index完全不同，则会视为不同的组件重新渲染

* 页面里很少变动的用v-if，变动的多的用v-show（if切换时性能差，show加载时性能差）

  v-if和v-for不要同用 / 使用computer

* 在react中，通过表单事件触发的state更新也会触发render，可以通过shouldComponentUpdate来避免

### 4. 谈谈v-if和v-show

v-if通过返回值判断是否加载或删除这个节点，v-show是通过display属性来控制是否渲染这个节点

**if切换时性能差，show加载时性能差**

   * if会转换成一个三元表达式来决定是否创建或销毁一个vnode，userProfile也会跟着操作，如果组件里有大量DOM节点，就会执行过多DOM操作。而show是通过切换display来实现的，组件还是会渲染。

   * 使用keep-alive可以创建组件缓存，结合if一定程度上既能保证首屏加载快又能切换不浪费资源

v-if和v-for不要同用

使用computer

diff:多用key，用item自身的id而不是index，否则颠倒顺序之后，index完全不同，则会视为不同的组件重新渲染

https://blog.csdn.net/grandpang/article/details/51329289

### 5. 强缓存和协商缓存

(1). **强制性缓存**：客户端自给自足

当浏览器去请求某个文件时，服务端就在respone header里对该文件做缓存配置，例如respone header中的cache-control，常见的设置是max-age public private no-cache no-store等

当设置了max-age时间时：

**public**：客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 。如果用户做了刷新操作，就向服务器发起http请求（即协商缓存）

**private**：只让客户端可以缓存该资源；代理服务器不缓存
 客户端在xxx秒内直接读取缓存,statu code:200

**immutable**：客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求

**no-cache**： 跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。

**no-store**： 不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。

expires也可以设置缓存的最终失效时间，与cache-control同时使用时后者优先级更高

(2). **协商缓存**：由服务器确定本地的缓存资源是否可用

在response header里设置如下属性，并在下次请求时在request header中带上它们：

````bash
etag: '5c20abbd-e2e8'
last-modified: Mon, 24 Dec 2018 09:49:49 GMT
````

etag为文件的hash，每个文件唯一，last-modified为精确到秒的文件最终修改时间。服务端根据这两个标识进行比对，判断是否需要返回新的资源：如果没有变，那就不变etag和last-modified

流程：

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回**304**状态码-->客户端用缓存的老资源。

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->过期-->返回**200**状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。

总结：

请求资源时，把用户本地该资源的 etag 同时带到服务端，服务端和最新资源做对比。
如果资源没更改，返回304，浏览器读取本地缓存。
如果资源有更改，返回200，返回最新的资源。

补充：

```csharp
// response header中的etag、last-modified在客户端重新向服务端发起请求时，会在request header中换个key名：
// response header
etag: '5c20abbd-e2e8'
last-modified: Mon, 24 Dec 2018 09:49:49 GMT
// request header 变为
if-none-matched: '5c20abbd-e2e8'
if-modified-since: Mon, 24 Dec 2018 09:49:49 GMT
```

牛角尖：为什么要有etag？

* 有的文件会周期性更改，但内容不改变
* 有的文件更新频率过快，而if-modified-since的检查粒度只到秒级
* 某些服务器不能精确得到文件的最后修改时间

## 七、CSS基础

### 1. margin坍缩：如果父元素没有设置上内边距或上边框，子元素的上边距就会和父元素的上边距重合

   **解决方法：让父元素触发BFC，如：float/position:absolute/overflow:hidden/display:inline-block**

   margin合并：上下两个元素相接触的margin重合

### 2. 谈谈BFC

### 3. display:none 和 visibility: hidden的区别

display：none的元素不会出现在render树，但是dom树上还是存在的，否则无法响应事件。
display：none后无论怎么修改子元素的display，都没用，因为根本不在render树中。

hidden的元素依旧会占位，只是看不到。子元素修改visilibilty: visible；是可以显现的，这个结果也正常，毕竟hidden的元素依旧存在于render树。



## 八、算法

### 1. 进程死锁：银行家算法