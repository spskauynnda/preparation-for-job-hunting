# 面试的坑

## 网络基础

1. tcp/udp
2. tcp三次握手四次挥手
3. 状态码
4. http和https的区别

## js基础

1. apply/call/bind

   * 共同点：都是用来重定义this对象的

     objA.foo.call(ObjB, ...) 

     objA.foo.apply(ObjB, ...)

     **objA.foo.bind(ObjB, ...)()**

   * 区别1：call和apply返回的是foo方法的返回值，bind返回的是一个新函数

   * 区别2：

     (1) 使用call时，后续参数**以逗号分割**传入被调用的函数中

     (2) 使用apply时，后续输入参数必须放在一个**数组**中传入

     (3) bind**返回是函数**，传入参数和call一样

   * 用途——react中的bind

     **类的方法默认不会绑定this，如果忘记绑定，则传入函数名并调用时，this值会是undefined**

     解决方法：bind或箭头函数

     1. 在构造函数constructor 内绑定`this.handleClick = this.handleClick.bind(this)`
     2. `handleClick = () => { ... }`
     3. 
   	
       	handleClick ( ) { ... }
     
       	render() {
       		return (
       	 		<button onClick={(e) => this.handleClick(e)}> ...
       	 		</button>
       		 )
       	}

   **手写bind** https://blog.csdn.net/q3254421/article/details/82999718

2. 原型链
    ![image-20210318200848599](.\原型链文字总结.png)
3. 匿名函数

   * 【重点】非严格模式下，this指向window，严格模式下，this指向undefined。同时匿名函数是一个没有指针的全局变量，通过window并不能找到这个匿名函数，这种调用具有安全性和隐匿性。

     并非匿名函数本身特殊，而是Property accessor语法影响了this。

     先看**一般情况**，在运行 `obj.foo()` 时，根据属性访问语法，函数会调用运算符"()"的左边部分，获取一个base为obj的referenceType，然后进行函数调用运算，则referenceType.base会为该函数执行环境的this提供引用。

     如果要消除referenceType带来的影响，很简单，`(1,obj,foo)()`就行了，因为分组运算符的加入，导致提前对referenceType进行了getValue操作，直接拿到函数对象进行函数调用运算，导致提供给该函数的执行环境关联的this值为null，在ES3中，规定此时glabal为this，而ES5的严格模式则修正了这一规则

     外层分组运算符的作用是让 匿名函数表达式合法. 因 javascript 语法限制. 禁止函数表达式中, function 关键字出现在表达式的第一个token位置. so. 必须借助其他辅助语法来完成所谓匿名函数的立即调用..比如 赋值表达式,逗号运算等等。显然匿名函数解释执行的结果不是一个referenceType .但是规则中有表述,当不是referenceType时. 仍然把null (undefined-SE5) 作为this 提供给该函数执行环境.

     完整问答链接：**匿名函数的this指向为什么是window?** https://www.zhihu.com/question/21958425/answer/19858492

   * 
   
4. **Array.prototype.slice()**

   Array.prototype.slice.call(arrLike)   等效于  [].slice.call(arrLike)   

   可用于将类数组对象arrLike转换为一个新数组

   ````
   // 类数组对象-字符串的表现
   const str = '1234'
   str.slice() // '1234'
   [].slice.call(str)  // ['1','2','3','4']
   function list1(item){ return [].slice.call(item) }
   function list2(){ return [].slice.call(arguments) }
   list1(str)     // ['1','2','3','4']
   list2(str)     // '1234'
   ````

   ```
   // mdn例子
   function list() {
     return Array.prototype.slice.call(arguments)
   }
   var list1 = list(1, 2, 3)  // [1, 2, 3]
   
   //使用bind"简化"list
   var unboundSlice = Array.prototype.slice
   var slice = Function.prototype.call.bind(unboundSlice)
   }
   function list() {
   	return slice(arguments)
   }
   var list2 = list(1,2,3)   // [1, 2, 3]
   ```

   ES6中Array.from()是该方法的新实现

## es6

> 主要内容
> 1. 函数的默认参数
> 2. 反引号：模板表达式/多行字符串
> 3. 拆包表达式：var { house, mouse} = $('body').data() 
> 4. 数组解构运算：...
> 5. Promise对象
> 6. 块作用域、let、const
> 7. 类
> 8. 模块化（标准实现CommonJS）
> 9. 数据结构（Map、Set）/新的类型方法，如include

1. var，const，let的区别

   var声明变量可以重复声明，而let不可以重复声明

   var是不受限于块级的，而let是受限于块级

　　var会与window相映射（会挂一个属性），而let不与window相映射

　　var可以在声明的上面访问变量，而let有暂存死区，在声明的上面访问变量会报错

　　const声明之后必须赋值，否则会报错

　　const定义不可变的量，改变了就会报错

　　const和let一样不会与window相映射、支持块级作用域、在声明的上面访问变量会报错

2. 查找两个数组的重复项

   let arrX = arr1.filter((item)=>arr2.includes(item))

   **Array.filter(function(){return 表达式})** 返回满足Array中满足表达式的元素

   **Array.includes()** indexOf的姊妹，它只返回true/false

3. const uniq = function(){

   ​	return Array.from(new Set(arguments[0]))

   }

   但是该方法对两个相同的对象可能无效，因为在比较的时候比较的是两个对象的名，即两个指针，哪怕两个深拷贝一样的对象，其地址也可能不同

## 现代框架

1. 简述react底层原理：

   包含调和阶段（比较前后VirtualDOM的不同，动态更新不同的部分，其中主要涉及diff算法）和render阶段

   **react diff算法**——

   假如使用循环递归对节点进行依次对比，算法复杂度将达到 O(n^3) ，而使用diff算法可降低至O(n) 

   策略一（**tree diff**）：
    Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。——只进行同级比较

   策略二（**component diff**）：
    拥有相同类的两个组件 生成相似的树形结构，
    拥有不同类的两个组件 生成不同的树形结构。 ——不同类的React组件会被当做完全不同的DOM结构而被完全替换

   策略三（**element diff**）：
    对于同一层级的一组子节点，通过唯一id区分。 ——开发人员可以通过给Virtual DOM一个唯一的key属性来暗示React这是同一个DOM结构，反之若key值不同则会被当做完全不同的DOM结构。

2. vue和react的区别？

3. vue和react的diff算法区别

   * vue diff时调动patch函数，参数是vnode和oldVnode，分别代表新旧节点。
   * vue比对节点，当节点元素类型相同，但是className不同，认为是不同类型元素，删除重建，而react会认为是同类型节点，只是修改节点属性
   * vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个。总体上，vue的对比方式更高效。

4. react/vue 生命周期？

5. redux？suga？


## 性能优化

1. cdn加速

2. 服务端渲染

3. 【vue】if切换时性能差，show加载时性能差

   * if会转换成一个三元表达式来决定是否创建或销毁一个vnode，userProfile也会跟着操作，如果组件里有大量DOM节点，就会执行过多DOM操作。而show是通过切换display来实现的，组件还是会渲染。

   * 使用keep-alive可以创建组件缓存，结合if一定程度上既能保证首屏加载快又能切换不浪费资源

4. 【vue】v-if和v-for不要同用
使用computer

5. diff:多用key，用item自身的id而不是index，否则颠倒顺序之后，index完全不同，则会视为不同的组件重新渲染

## CSS基础

1. margin坍缩：如果父元素没有设置上内边距或上边框，子元素的上边距就会和父元素的上边距重合

   **解决方法：让父元素触发BFC，如：float/position:absolute/overflow:hidden/display:inline-block**

   margin合并：上下两个元素相接触的margin重合

2. 谈谈BFC

## 算法

1. 进程死锁：银行家算法
2. 